Interrupt Vectors
    00000 940C 007F JMP	__start|__text_start

Program Code (text area)
__start|__text_start:
    0007F EFCF      LDI	R28,0xFF
    00080 E1D0      LDI	R29,0x10
    00081 BFCD      OUT	0x3D,R28
    00082 BFDE      OUT	0x3E,R29
    00083 51CE      SUBI	R28,0x1E
    00084 40D0      SBCI	R29,0
    00085 EA0A      LDI	R16,0xAA
    00086 8308      ST	Y,R16
    00087 2400      CLR	R0
    00088 E7E1      LDI	R30,0x71
    00089 E0F1      LDI	R31,1
    0008A E011      LDI	R17,1
    0008B 38E9      CPI	R30,0x89
    0008C 07F1      CPC	R31,R17
    0008D F011      BEQ	0x0090
    0008E 9201      ST	Z+,R0
    0008F CFFB      RJMP	0x008B
    00090 8300      ST	Z,R16
    00091 E8EC      LDI	R30,0x8C
    00092 E0F0      LDI	R31,0
    00093 E0A0      LDI	R26,0
    00094 E0B1      LDI	R27,1
    00095 E010      LDI	R17,0
    00096 E000      LDI	R16,0
    00097 BF0B      OUT	0x3B,R16
    00098 3FED      CPI	R30,0xFD
    00099 07F1      CPC	R31,R17
    0009A F021      BEQ	0x009F
    0009B 95C8      LPM
    0009C 9631      ADIW	R30,1
    0009D 920D      ST	X+,R0
    0009E CFF9      RJMP	0x0098
    0009F 940E 00A2 CALL	_main
_exit:
    000A1 CFFF      RJMP	_exit
FILE: F:\工作\单片机\WorkSpace\AccessControlSystem\AccessControlSystem.c
(0001) #include <iom128v.h>
(0002) #include <macros.h>
(0003) #include "USART_Operate.h"
(0004) #include "FingerprintOperate.h"
(0005) #include "LCD_Operate.h"
(0006) #include "KeyboardOperate.h"
(0007) #include "GlobalDefine.h"
(0008) #include "DeviceInitialize.h"
(0009) 
(0010) void main(void)
(0011) {
(0012) 	init_devices(); //设备初始化
_main:
    000A2 940E 054D CALL	_init_devices
(0013) 	
(0014) 	delay(10); //等待设备初始化完成
    000A4 E00A      LDI	R16,0xA
    000A5 940E 04C5 CALL	_delay
(0015) 	led_blink(3); //指示灯闪烁3次提示设备初始化完成
    000A7 E003      LDI	R16,3
    000A8 940E 052A CALL	_led_blink
(0016) 	USART0_Transmit_String("Hello World!");
    000AA E002      LDI	R16,2
    000AB E011      LDI	R17,1
    000AC 940E 0113 CALL	_USART0_Transmit_String
(0017) 	USART1_Transmit_String("Hello World!");
    000AE E002      LDI	R16,2
    000AF E011      LDI	R17,1
    000B0 940E 0174 CALL	_USART1_Transmit_String
    000B2 C02C      RJMP	0x00DF
(0018) 	while(1) //待机
(0019) 	{
(0020) 		//while(LCD_Busy());
(0021) 		//LCD_Clear_Screen(gray);
(0022) 		//USART0_Transmit_String("DS32(0,50,'实验室门禁系统',1);DS16(65,100,'显示模块测试',2);\r\n");
(0023) 		//delay(100);
(0024) 		switch(Keyboard_Scan())
    000B3 940E 03E7 CALL	_Keyboard_Scan
    000B5 2F40      MOV	R20,R16
    000B6 2755      CLR	R21
    000B7 3441      CPI	R20,0x41
    000B8 E0E0      LDI	R30,0
    000B9 075E      CPC	R21,R30
    000BA F069      BEQ	0x00C8
    000BB 3442      CPI	R20,0x42
    000BC E0E0      LDI	R30,0
    000BD 075E      CPC	R21,R30
    000BE F071      BEQ	0x00CD
    000BF 3443      CPI	R20,0x43
    000C0 E0E0      LDI	R30,0
    000C1 075E      CPC	R21,R30
    000C2 F069      BEQ	0x00D0
    000C3 3444      CPI	R20,0x44
    000C4 E0E0      LDI	R30,0
    000C5 075E      CPC	R21,R30
    000C6 F089      BEQ	0x00D8
    000C7 C017      RJMP	0x00DF
(0025) 		{
(0026) 			case 'A': FINGERPRINT_add_new_user(0); break;
    000C8 2700      CLR	R16
    000C9 2711      CLR	R17
    000CA 940E 0366 CALL	_FINGERPRINT_add_new_user
    000CC C012      RJMP	0x00DF
(0027) 			case 'B': FINGERPRINT_search_reg_user(); break;
    000CD 940E 03A8 CALL	_FINGERPRINT_search_reg_user
    000CF C00F      RJMP	0x00DF
(0028) 			case 'C': led_on(3); LCD_Clear_Screen(gray); break;
    000D0 E003      LDI	R16,3
    000D1 940E 04DB CALL	_led_on
    000D3 E000      LDI	R16,0
    000D4 E011      LDI	R17,1
    000D5 940E 03D2 CALL	_LCD_Clear_Screen
    000D7 C007      RJMP	0x00DF
(0029) 			case 'D': led_on(4); USART1_Transmit_String("Hello World!"); break;
    000D8 E004      LDI	R16,4
    000D9 940E 04DB CALL	_led_on
    000DB E002      LDI	R16,2
    000DC E011      LDI	R17,1
    000DD 940E 0174 CALL	_USART1_Transmit_String
    000DF CFD3      RJMP	0x00B3
    000E0 9508      RET
FILE: F:\工作\单片机\WorkSpace\AccessControlSystem\USART_Operate.c
(0001) //USART_Operate.c
(0002) 
(0003) #include <iom128v.h>
(0004) #include "USART_Operate.h"
(0005) #include "DeviceInitialize.h"
(0006) 
(0007) /*-------------------- USART0 --------------------*/
(0008) 
(0009) //USART0初始化
(0010) void USART0_Init(unsigned int ubrr)
(0011) {
(0012) 	UCSR0B = 0x00; //关闭收器与发送器, 等待设置波特率
_USART0_Init:
  ubrr                 --> R16
    000E1 2422      CLR	R2
    000E2 B82A      OUT	0x0A,R2
(0013) 	UCSR0A = 0x00; //控制和状态寄存器0A初值
    000E3 B82B      OUT	0x0B,R2
(0014) 	UBRR0H = (unsigned char)(ubrr>>8); //设置波特率
    000E4 0118      MOVW	R2,R16
    000E5 2C23      MOV	R2,R3
    000E6 2433      CLR	R3
    000E7 9220 0090 STS	0x90,R2
(0015) 	UBRR0L = (unsigned char)ubrr;
    000E9 B909      OUT	0x09,R16
(0016) 	UCSR0C = (0<<USBS0)|(3<<UCSZ00); //设置帧格式: 8个数据位, 1个停止位
    000EA E086      LDI	R24,6
    000EB 9380 0095 STS	0x95,R24
(0017) 	UCSR0B = (1<<RXEN0)|(1<<TXEN0); //使能接收器与发送器
    000ED E188      LDI	R24,0x18
    000EE B98A      OUT	0x0A,R24
    000EF 9508      RET
(0018) }
(0019) 
(0020) //USART0以5到8个数据位的方式发送帧
(0021) void USART0_Transmit(unsigned char data)
(0022) {
(0023) 	while(!(UCSR0A & (1<<UDRE0))); //等待发送缓冲器为空
_USART0_Transmit:
  data                 --> R16
    000F0 9B5D      SBIS	0x0B,5
    000F1 CFFE      RJMP	_USART0_Transmit
(0024) 	UDR0 = data; //将数据放入缓冲器, 发送数据
    000F2 B90C      OUT	0x0C,R16
    000F3 9508      RET
(0025) }
(0026) 
(0027) //USART0以9个数据位的方式发送帧
(0028) void USART0_Transmit_9bits(unsigned int data)
(0029) {
(0030) 	while(!(UCSR0A & (1<<UDRE0))); //等待发送缓冲器为空
_USART0_Transmit_9bits:
  data                 --> R16
    000F4 9B5D      SBIS	0x0B,5
    000F5 CFFE      RJMP	_USART0_Transmit_9bits
(0031) 	UCSR0B &= ~(1<<TXB80); //将第9位复制到TXB8
    000F6 9850      CBI	0x0A,0
(0032) 	if(data & 0x0100)
    000F7 FF10      SBRS	R17,0
    000F8 C001      RJMP	0x00FA
(0033) 		UCSR0B |= (1<<TXB80);
    000F9 9A50      SBI	0x0A,0
(0034) 	UDR0 = data; //将数据放入缓冲器, 发送数据
    000FA B90C      OUT	0x0C,R16
    000FB 9508      RET
(0035) }
(0036) 
(0037) //USART0以5到8个数据位的方式接收帧
(0038) unsigned char USART0_Receive(void)
(0039) {
(0040) 	while(!(UCSR0A & (1<<RXC0))); //等待接收数据
_USART0_Receive:
    000FC 9B5F      SBIS	0x0B,7
    000FD CFFE      RJMP	_USART0_Receive
(0041) 	return UDR0; //从缓冲器中获取并返回数据
    000FE B10C      IN	R16,0x0C
    000FF 9508      RET
_USART0_Receive_9bits:
  resl                 --> R18
  status               --> R20
  resh                 --> R16
    00100 934A      ST	-Y,R20
(0042) }
(0043) 
(0044) //USART0以9个数据位的方式接收帧
(0045) unsigned int USART0_Receive_9bits(void)
(0046) {
(0047) 	unsigned char status, resh, resl;
(0048) 
(0049) 	while(!(UCSR0A & (1<<RXC0))); //等待接收数据
    00101 9B5F      SBIS	0x0B,7
    00102 CFFE      RJMP	0x0101
(0050) 	status = UCSR0A; //从缓冲器中获得状态、第9位及数据
    00103 B14B      IN	R20,0x0B
(0051) 	resh = UCSR0B;
    00104 B10A      IN	R16,0x0A
(0052) 	resl = UDR0;
    00105 B12C      IN	R18,0x0C
(0053) 	if(status & (1<<FE0) | (1<<DOR0) | (1<<UPE0)) //如果出错, 返回-1
    00106 2F84      MOV	R24,R20
    00107 7180      ANDI	R24,0x10
    00108 608C      ORI	R24,0xC
    00109 F019      BEQ	0x010D
(0054) 		return -1;
    0010A EF0F      LDI	R16,0xFF
    0010B EF1F      LDI	R17,0xFF
    0010C C004      RJMP	0x0111
(0055) 	resh = (resh >> 1) & 0x01; //过滤第9位数据, 然后返回
    0010D 9506      LSR	R16
    0010E 7001      ANDI	R16,1
(0056) 	return ((resh << 8) | resl);
    0010F 2F10      MOV	R17,R16
    00110 2F02      MOV	R16,R18
    00111 9149      LD	R20,Y+
    00112 9508      RET
_USART0_Transmit_String:
  p                    --> R20
    00113 934A      ST	-Y,R20
    00114 935A      ST	-Y,R21
    00115 01A8      MOVW	R20,R16
(0057) }
(0058) 
(0059) //USART0以5到8个数据位的方式发送字符串
(0060) void USART0_Transmit_String(unsigned char *p)
(0061) {
    00116 C005      RJMP	0x011C
(0062)     while(*p)
(0063)     {
(0064)         USART0_Transmit(*p);
    00117 01FA      MOVW	R30,R20
    00118 8100      LD	R16,Z
    00119 DFD6      RCALL	_USART0_Transmit
(0065)         p++;
    0011A 5F4F      SUBI	R20,0xFF
    0011B 4F5F      SBCI	R21,0xFF
    0011C 01FA      MOVW	R30,R20
    0011D 8020      LD	R2,Z
    0011E 2022      TST	R2
    0011F F7B9      BNE	0x0117
    00120 9159      LD	R21,Y+
    00121 9149      LD	R20,Y+
    00122 9508      RET
(0066)     }
(0067) }
(0068) 
(0069) //USART0刷新接收缓冲器
(0070) void USART0_Flush(void)
(0071) {
_USART0_Flush:
  dummy                --> R16
    00123 C001      RJMP	0x0125
(0072) 	unsigned char dummy;
(0073) 	while(UCSR0A & (1<<RXC0))
(0074) 		dummy = UDR0;
    00124 B10C      IN	R16,0x0C
    00125 995F      SBIC	0x0B,7
    00126 CFFD      RJMP	0x0124
    00127 9508      RET
(0075) }
(0076) 
(0077) /*-------------------- USART1 --------------------*/
(0078) 
(0079) //USART1初始化
(0080) void USART1_Init(unsigned int ubrr)
(0081) {
(0082) 	UCSR1B = 0x00; //关闭收器与发送器, 等待设置波特率
_USART1_Init:
  ubrr                 --> R16
    00128 2422      CLR	R2
    00129 9220 009A STS	0x9A,R2
(0083) 	UCSR1A = 0x00; //控制和状态寄存器1A初值
    0012B 9220 009B STS	0x9B,R2
(0084) 	UBRR1H = (unsigned char)(ubrr>>8); //设置波特率
    0012D 0118      MOVW	R2,R16
    0012E 2C23      MOV	R2,R3
    0012F 2433      CLR	R3
    00130 9220 0098 STS	0x98,R2
(0085) 	UBRR1L = (unsigned char)ubrr;
    00132 9300 0099 STS	0x99,R16
(0086) 	UCSR1C = (0<<USBS1)|(3<<UCSZ10); //设置帧格式: 8个数据位, 1个停止位
    00134 E086      LDI	R24,6
    00135 9380 009D STS	0x9D,R24
(0087) 	UCSR1B = (1<<RXEN1)|(1<<TXEN1); //使能接收器与发送器
    00137 E188      LDI	R24,0x18
    00138 9380 009A STS	0x9A,R24
    0013A 9508      RET
(0088) }
(0089) 
(0090) //USART1以5到8个数据位的方式发送帧
(0091) void USART1_Transmit(unsigned char data)
(0092) {
(0093) 	while(!(UCSR1A & (1<<UDRE1))); //等待发送缓冲器为空
_USART1_Transmit:
  data                 --> R16
    0013B 9020 009B LDS	R2,0x9B
    0013D FE25      SBRS	R2,5
    0013E CFFC      RJMP	_USART1_Transmit
(0094) 	UDR1 = data; //将数据放入缓冲器, 发送数据
    0013F 9300 009C STS	0x9C,R16
    00141 9508      RET
(0095) }
(0096) 
(0097) //USART1以9个数据位的方式发送帧
(0098) void USART1_Transmit_9bits(unsigned int data)
(0099) {
(0100) 	while(!(UCSR1A & (1<<UDRE1))); //等待发送缓冲器为空
_USART1_Transmit_9bits:
  data                 --> R16
    00142 9020 009B LDS	R2,0x9B
    00144 FE25      SBRS	R2,5
    00145 CFFC      RJMP	_USART1_Transmit_9bits
(0101) 	UCSR1B &= ~(1<<TXB81); //将第9位复制到TXB8
    00146 9180 009A LDS	R24,0x9A
    00148 7F8E      ANDI	R24,0xFE
    00149 9380 009A STS	0x9A,R24
(0102) 	if(data & 0x0100)
    0014B FF10      SBRS	R17,0
    0014C C005      RJMP	0x0152
(0103) 		UCSR1B |= (1<<TXB81);
    0014D 9180 009A LDS	R24,0x9A
    0014F 6081      ORI	R24,1
    00150 9380 009A STS	0x9A,R24
(0104) 	UDR1 = data; //将数据放入缓冲器, 发送数据
    00152 9300 009C STS	0x9C,R16
    00154 9508      RET
(0105) }
(0106) 
(0107) //USART1以5到8个数据位的方式接收帧
(0108) unsigned char USART1_Receive(void)
(0109) {
(0110) 	while(!(UCSR1A & (1<<RXC1))); //等待接收数据
_USART1_Receive:
    00155 9020 009B LDS	R2,0x9B
    00157 FE27      SBRS	R2,7
    00158 CFFC      RJMP	_USART1_Receive
(0111) 	return UDR1; //从缓冲器中获取并返回数据
    00159 9100 009C LDS	R16,0x9C
    0015B 9508      RET
_USART1_Receive_9bits:
  resl                 --> R18
  status               --> R20
  resh                 --> R16
    0015C 934A      ST	-Y,R20
(0112) }
(0113) 
(0114) //USART1以9个数据位的方式接收帧
(0115) unsigned int USART1_Receive_9bits(void)
(0116) {
(0117) 	unsigned char status, resh, resl;
(0118) 
(0119) 	while(!(UCSR1A & (1<<RXC1))); //等待接收数据
    0015D 9020 009B LDS	R2,0x9B
    0015F FE27      SBRS	R2,7
    00160 CFFC      RJMP	0x015D
(0120) 	status = UCSR1A; //从缓冲器中获得状态、第9位及数据
    00161 9140 009B LDS	R20,0x9B
(0121) 	resh = UCSR1B;
    00163 9100 009A LDS	R16,0x9A
(0122) 	resl = UDR1;
    00165 9120 009C LDS	R18,0x9C
(0123) 	if(status & (1<<FE1) | (1<<DOR1) | (1<<UPE1)) //如果出错, 返回-1
    00167 2F84      MOV	R24,R20
    00168 7180      ANDI	R24,0x10
    00169 608C      ORI	R24,0xC
    0016A F019      BEQ	0x016E
(0124) 		return -1;
    0016B EF0F      LDI	R16,0xFF
    0016C EF1F      LDI	R17,0xFF
    0016D C004      RJMP	0x0172
(0125) 	resh = (resh >> 1) & 0x01; //过滤第9位数据, 然后返回
    0016E 9506      LSR	R16
    0016F 7001      ANDI	R16,1
(0126) 	return ((resh << 8) | resl);
    00170 2F10      MOV	R17,R16
    00171 2F02      MOV	R16,R18
    00172 9149      LD	R20,Y+
    00173 9508      RET
_USART1_Transmit_String:
  p                    --> R20
    00174 934A      ST	-Y,R20
    00175 935A      ST	-Y,R21
    00176 01A8      MOVW	R20,R16
(0127) }
(0128) 
(0129) //USART1以5到8个数据位的方式发送字符串
(0130) void USART1_Transmit_String(unsigned char *p)
(0131) {
    00177 C005      RJMP	0x017D
(0132)     while(*p)
(0133)     {
(0134)         USART1_Transmit(*p);
    00178 01FA      MOVW	R30,R20
    00179 8100      LD	R16,Z
    0017A DFC0      RCALL	_USART1_Transmit
(0135)         p++;
    0017B 5F4F      SUBI	R20,0xFF
    0017C 4F5F      SBCI	R21,0xFF
    0017D 01FA      MOVW	R30,R20
    0017E 8020      LD	R2,Z
    0017F 2022      TST	R2
    00180 F7B9      BNE	0x0178
    00181 9159      LD	R21,Y+
    00182 9149      LD	R20,Y+
    00183 9508      RET
(0136)     }
(0137) }
(0138) 
(0139) //USART1刷新接收缓冲器
(0140) void USART1_Flush(void)
(0141) {
_USART1_Flush:
  dummy                --> R16
    00184 C002      RJMP	0x0187
(0142) 	unsigned char dummy;
(0143) 	while(UCSR1A & (1<<RXC1))
(0144) 		dummy = UDR1;
    00185 9100 009C LDS	R16,0x9C
    00187 9020 009B LDS	R2,0x9B
    00189 FC27      SBRC	R2,7
    0018A CFFA      RJMP	0x0185
    0018B 9508      RET
_FINGERPRINT_Cmd_Get_Img:
  i                    --> R20
    0018C 934A      ST	-Y,R20
FILE: F:\工作\单片机\WorkSpace\AccessControlSystem\FingerprintOperate.c
(0001) //FingerprintOperate.c
(0002) 
(0003) #include "FingerprintOperate.h"
(0004) #include "USART_Operate.h"
(0005) #include "GlobalDefine.h"
(0006) 
(0007) #define UART1_Send_Byte USART1_Transmit
(0008) #define UART1_Receive_Byte USART1_Receive
(0009) 
(0010) volatile unsigned char UART1_FINGERPRINT_RECEVICE_BUFFER[24]; //默认全为1
(0011) 
(0012) //FINGERPRINT通信协议定义
(0013) unsigned char FP_Pack_Head[6]={0xEF,0x01,0xFF,0xFF,0xFF,0xFF}; //协议包头
(0014) unsigned char FP_Get_Img[6]={0x01,0x00,0x03,0x01,0x00,0x05}; //获得指纹图像
(0015) unsigned char FP_Templete_Num[6]={0x01,0x00,0x03,0x1D,0x00,0x21}; //获得模版总数
(0016) unsigned char FP_Search[11]={0x01,0x00,0x08,0x04,0x01,0x00,0x00,0x03,0xE7,0x00,0xF8}; //搜索指纹搜索范围0-999
(0017) unsigned char FP_Search_0_9[11]={0x01,0x00,0x08,0x04,0x01,0x00,0x00,0x00,0x0A,0x00,0x18}; //搜索0-9号指纹
(0018) unsigned char FP_Img_To_Buffer1[7]={0x01,0x00,0x04,0x02,0x01,0x00,0x08}; //将图像放入到BUFFER1
(0019) unsigned char FP_Img_To_Buffer2[7]={0x01,0x00,0x04,0x02,0x02,0x00,0x09}; //将图像放入到BUFFER2
(0020) unsigned char FP_Reg_Model[6]={0x01,0x00,0x03,0x05,0x00,0x09}; //将BUFFER1跟BUFFER2合成特征模版
(0021) unsigned char FP_Delet_All_Model[6]={0x01,0x00,0x03,0x0d,0x00,0x11}; //删除指纹模块里所有的模版
(0022) volatile unsigned char FP_Save_Finger[9]={0x01,0x00,0x06,0x06,0x01,0x00,0x0B,0x00,0x19}; //将BUFFER1中的特征码存放到指定的位置
(0023) volatile unsigned char FP_Delete_Model[10]={0x01,0x00,0x07,0x0C,0x00,0x00,0x00,0x1,0x00,0x00}; //删除指定的模版
(0024) //volatile unsigned char FINGER_NUM;
(0025) 
(0026) /*-------------------- FINGERPRINT命令字 --------------------*/
(0027) 
(0028) //获得指纹图像命令
(0029) void FINGERPRINT_Cmd_Get_Img(void)
(0030) {
(0031) 	unsigned char i;
(0032) 
(0033) 	for(i=0;i<6;i++) //发送包头
    0018D 2744      CLR	R20
    0018E C00A      RJMP	0x0199
(0034) 		UART1_Send_Byte(FP_Pack_Head[i]);
    0018F E08F      LDI	R24,0xF
    00190 E091      LDI	R25,1
    00191 2FE4      MOV	R30,R20
    00192 27FF      CLR	R31
    00193 0FE8      ADD	R30,R24
    00194 1FF9      ADC	R31,R25
    00195 8100      LD	R16,Z
    00196 940E 013B CALL	_USART1_Transmit
    00198 9543      INC	R20
    00199 3046      CPI	R20,6
    0019A F3A0      BCS	0x018F
(0035) 
(0036) 	for(i=0;i<6;i++) //发送命令0x1d
    0019B 2744      CLR	R20
    0019C C00A      RJMP	0x01A7
(0037) 		UART1_Send_Byte(FP_Get_Img[i]);
    0019D E185      LDI	R24,0x15
    0019E E091      LDI	R25,1
    0019F 2FE4      MOV	R30,R20
    001A0 27FF      CLR	R31
    001A1 0FE8      ADD	R30,R24
    001A2 1FF9      ADC	R31,R25
    001A3 8100      LD	R16,Z
    001A4 940E 013B CALL	_USART1_Transmit
    001A6 9543      INC	R20
    001A7 3046      CPI	R20,6
    001A8 F3A0      BCS	0x019D
    001A9 9149      LD	R20,Y+
    001AA 9508      RET
_FINGERPRINT_Cmd_Img_To_Buffer1:
  i                    --> R20
    001AB 934A      ST	-Y,R20
(0038) }
(0039) 
(0040) //将图像转换成特征码存放在Buffer1中
(0041) void FINGERPRINT_Cmd_Img_To_Buffer1(void)
(0042) {
(0043) 	unsigned char i;
(0044) 
(0045) 	for(i=0;i<6;i++) //发送包头
    001AC 2744      CLR	R20
    001AD C00A      RJMP	0x01B8
(0046) 		UART1_Send_Byte(FP_Pack_Head[i]);
    001AE E08F      LDI	R24,0xF
    001AF E091      LDI	R25,1
    001B0 2FE4      MOV	R30,R20
    001B1 27FF      CLR	R31
    001B2 0FE8      ADD	R30,R24
    001B3 1FF9      ADC	R31,R25
    001B4 8100      LD	R16,Z
    001B5 940E 013B CALL	_USART1_Transmit
    001B7 9543      INC	R20
    001B8 3046      CPI	R20,6
    001B9 F3A0      BCS	0x01AE
(0047) 
(0048) 	for(i=0;i<7;i++) //发送命令将图像转换成特征码存放在CHAR_buffer1
    001BA 2744      CLR	R20
    001BB C00A      RJMP	0x01C6
(0049) 		UART1_Send_Byte(FP_Img_To_Buffer1[i]);
    001BC E387      LDI	R24,0x37
    001BD E091      LDI	R25,1
    001BE 2FE4      MOV	R30,R20
    001BF 27FF      CLR	R31
    001C0 0FE8      ADD	R30,R24
    001C1 1FF9      ADC	R31,R25
    001C2 8100      LD	R16,Z
    001C3 940E 013B CALL	_USART1_Transmit
    001C5 9543      INC	R20
    001C6 3047      CPI	R20,7
    001C7 F3A0      BCS	0x01BC
    001C8 9149      LD	R20,Y+
    001C9 9508      RET
_FINGERPRINT_Cmd_Img_To_Buffer2:
  i                    --> R20
    001CA 934A      ST	-Y,R20
(0050) }
(0051) 
(0052) //将图像转换成特征码存放在Buffer2中
(0053) void FINGERPRINT_Cmd_Img_To_Buffer2(void)
(0054) {
(0055) 	unsigned char i;
(0056) 
(0057) 	for(i=0;i<6;i++) //发送包头
    001CB 2744      CLR	R20
    001CC C00A      RJMP	0x01D7
(0058) 		UART1_Send_Byte(FP_Pack_Head[i]);
    001CD E08F      LDI	R24,0xF
    001CE E091      LDI	R25,1
    001CF 2FE4      MOV	R30,R20
    001D0 27FF      CLR	R31
    001D1 0FE8      ADD	R30,R24
    001D2 1FF9      ADC	R31,R25
    001D3 8100      LD	R16,Z
    001D4 940E 013B CALL	_USART1_Transmit
    001D6 9543      INC	R20
    001D7 3046      CPI	R20,6
    001D8 F3A0      BCS	0x01CD
(0059) 
(0060) 	for(i=0;i<7;i++) //发送命令将图像转换成特征码存放在CHAR_buffer2
    001D9 2744      CLR	R20
    001DA C00A      RJMP	0x01E5
(0061) 		UART1_Send_Byte(FP_Img_To_Buffer2[i]);
    001DB E38E      LDI	R24,0x3E
    001DC E091      LDI	R25,1
    001DD 2FE4      MOV	R30,R20
    001DE 27FF      CLR	R31
    001DF 0FE8      ADD	R30,R24
    001E0 1FF9      ADC	R31,R25
    001E1 8100      LD	R16,Z
    001E2 940E 013B CALL	_USART1_Transmit
    001E4 9543      INC	R20
    001E5 3047      CPI	R20,7
    001E6 F3A0      BCS	0x01DB
    001E7 9149      LD	R20,Y+
    001E8 9508      RET
_FINGERPRINT_Cmd_Reg_Model:
  i                    --> R20
    001E9 934A      ST	-Y,R20
(0062) }
(0063) 
(0064) //将BUFFER1跟BUFFER2中的特征码合并成指纹模版
(0065) void FINGERPRINT_Cmd_Reg_Model(void)
(0066) {
(0067) 	unsigned char i;
(0068) 
(0069) 	for(i=0;i<6;i++) //包头
    001EA 2744      CLR	R20
    001EB C00A      RJMP	0x01F6
(0070) 		UART1_Send_Byte(FP_Pack_Head[i]);
    001EC E08F      LDI	R24,0xF
    001ED E091      LDI	R25,1
    001EE 2FE4      MOV	R30,R20
    001EF 27FF      CLR	R31
    001F0 0FE8      ADD	R30,R24
    001F1 1FF9      ADC	R31,R25
    001F2 8100      LD	R16,Z
    001F3 940E 013B CALL	_USART1_Transmit
    001F5 9543      INC	R20
    001F6 3046      CPI	R20,6
    001F7 F3A0      BCS	0x01EC
(0071) 
(0072) 	for(i=0;i<6;i++) //命令合并指纹模版
    001F8 2744      CLR	R20
    001F9 C00A      RJMP	0x0204
(0073) 		UART1_Send_Byte(FP_Reg_Model[i]);
    001FA E485      LDI	R24,0x45
    001FB E091      LDI	R25,1
    001FC 2FE4      MOV	R30,R20
    001FD 27FF      CLR	R31
    001FE 0FE8      ADD	R30,R24
    001FF 1FF9      ADC	R31,R25
    00200 8100      LD	R16,Z
    00201 940E 013B CALL	_USART1_Transmit
    00203 9543      INC	R20
    00204 3046      CPI	R20,6
    00205 F3A0      BCS	0x01FA
    00206 9149      LD	R20,Y+
    00207 9508      RET
_FINGERPRINT_Cmd_Delete_All_Model:
  i                    --> R20
    00208 934A      ST	-Y,R20
(0074) }
(0075) 
(0076) //删除指纹模块里的所有指纹模版
(0077) void FINGERPRINT_Cmd_Delete_All_Model(void)
(0078) {
(0079) 	unsigned char i;
(0080) 
(0081) 	for(i=0;i<6;i++) //包头
    00209 2744      CLR	R20
    0020A C00A      RJMP	0x0215
(0082) 		UART1_Send_Byte(FP_Pack_Head[i]);
    0020B E08F      LDI	R24,0xF
    0020C E091      LDI	R25,1
    0020D 2FE4      MOV	R30,R20
    0020E 27FF      CLR	R31
    0020F 0FE8      ADD	R30,R24
    00210 1FF9      ADC	R31,R25
    00211 8100      LD	R16,Z
    00212 940E 013B CALL	_USART1_Transmit
    00214 9543      INC	R20
    00215 3046      CPI	R20,6
    00216 F3A0      BCS	0x020B
(0083) 
(0084) 	for(i=0;i<6;i++) //命令合并指纹模版
    00217 2744      CLR	R20
    00218 C00A      RJMP	0x0223
(0085) 		UART1_Send_Byte(FP_Delet_All_Model[i]);
    00219 E48B      LDI	R24,0x4B
    0021A E091      LDI	R25,1
    0021B 2FE4      MOV	R30,R20
    0021C 27FF      CLR	R31
    0021D 0FE8      ADD	R30,R24
    0021E 1FF9      ADC	R31,R25
    0021F 8100      LD	R16,Z
    00220 940E 013B CALL	_USART1_Transmit
    00222 9543      INC	R20
    00223 3046      CPI	R20,6
    00224 F3A0      BCS	0x0219
    00225 9149      LD	R20,Y+
    00226 9508      RET
_FINGERPRINT_Cmd_Delete_Model:
  sum                  --> Y,+0
  i                    --> R20
  Page_ID              --> R20
    00227 934A      ST	-Y,R20
    00228 935A      ST	-Y,R21
    00229 01A8      MOVW	R20,R16
    0022A 9722      SBIW	R28,2
(0086) }
(0087) 
(0088) //删除指纹模块里的指定指纹模版
(0089) void FINGERPRINT_Cmd_Delete_Model(unsigned int Page_ID)
(0090) {
(0091) 	volatile unsigned int sum = 0;
    0022B 2422      CLR	R2
    0022C 2433      CLR	R3
    0022D 8239      STD	Y+1,R3
    0022E 8228      ST	Y,R2
(0092) 	unsigned char i;
(0093) 
(0094) 	//Delete_MODEL[10]={0x01,0x00,0x07,0x0C,0x00,0x00,0x00,0x1,0x00,0x00}; //删除指定的模版
(0095) 
(0096) 	FP_Delete_Model[4] = (Page_ID & 0xFF00) >> 8;
    0022F 01CA      MOVW	R24,R20
    00230 7080      ANDI	R24,0
    00231 2F89      MOV	R24,R25
    00232 2799      CLR	R25
    00233 9380 015E STS	FP_Delete_Model+4,R24
(0097) 	FP_Delete_Model[5] = (Page_ID & 0x00FF);
    00235 01CA      MOVW	R24,R20
    00236 7090      ANDI	R25,0
    00237 9380 015F STS	FP_Delete_Model+5,R24
(0098) 
(0099) 	for(i=0;i<8;i++)
    00239 2744      CLR	R20
    0023A C00F      RJMP	0x024A
(0100) 		sum = sum + FP_Delete_Model[i];
    0023B E58A      LDI	R24,0x5A
    0023C E091      LDI	R25,1
    0023D 2FE4      MOV	R30,R20
    0023E 27FF      CLR	R31
    0023F 0FE8      ADD	R30,R24
    00240 1FF9      ADC	R31,R25
    00241 8020      LD	R2,Z
    00242 2433      CLR	R3
    00243 8048      LD	R4,Y
    00244 8059      LDD	R5,Y+1
    00245 0C42      ADD	R4,R2
    00246 1C53      ADC	R5,R3
    00247 8259      STD	Y+1,R5
    00248 8248      ST	Y,R4
    00249 9543      INC	R20
    0024A 3048      CPI	R20,0x8
    0024B F378      BCS	0x023B
(0101) 
(0102) 	//UART1_Send_Byte(sum);
(0103) 	FP_Delete_Model[8] = (sum & 0xFF00)>>8;
    0024C 8188      LD	R24,Y
    0024D 8199      LDD	R25,Y+1
    0024E 7080      ANDI	R24,0
    0024F 011C      MOVW	R2,R24
    00250 2C23      MOV	R2,R3
    00251 2433      CLR	R3
    00252 9220 0162 STS	FP_Delete_Model+8,R2
(0104) 	FP_Delete_Model[9] =  sum & 0x00FF;
    00254 8188      LD	R24,Y
    00255 8199      LDD	R25,Y+1
    00256 7090      ANDI	R25,0
    00257 9380 0163 STS	FP_Delete_Model+9,R24
(0105) 
(0106) 	for(i=0;i<6;i++) //包头
    00259 2744      CLR	R20
    0025A C00A      RJMP	0x0265
(0107) 		UART1_Send_Byte(FP_Pack_Head[i]);
    0025B E08F      LDI	R24,0xF
    0025C E091      LDI	R25,1
    0025D 2FE4      MOV	R30,R20
    0025E 27FF      CLR	R31
    0025F 0FE8      ADD	R30,R24
    00260 1FF9      ADC	R31,R25
    00261 8100      LD	R16,Z
    00262 940E 013B CALL	_USART1_Transmit
    00264 9543      INC	R20
    00265 3046      CPI	R20,6
    00266 F3A0      BCS	0x025B
(0108) 
(0109) 	for(i=0;i<10;i++) //命令合并指纹模版
    00267 2744      CLR	R20
    00268 C00A      RJMP	0x0273
(0110) 		UART1_Send_Byte(FP_Delete_Model[i]);
    00269 E58A      LDI	R24,0x5A
    0026A E091      LDI	R25,1
    0026B 2FE4      MOV	R30,R20
    0026C 27FF      CLR	R31
    0026D 0FE8      ADD	R30,R24
    0026E 1FF9      ADC	R31,R25
    0026F 8100      LD	R16,Z
    00270 940E 013B CALL	_USART1_Transmit
    00272 9543      INC	R20
    00273 304A      CPI	R20,0xA
    00274 F3A0      BCS	0x0269
    00275 9622      ADIW	R28,2
    00276 9159      LD	R21,Y+
    00277 9149      LD	R20,Y+
    00278 9508      RET
_FINGERPRINT_Cmd_Get_Templete_Num:
  temp                 --> Y,+0
  i                    --> R20
    00279 934A      ST	-Y,R20
    0027A 935A      ST	-Y,R21
    0027B 972E      SBIW	R28,0xE
(0111) }
(0112) 
(0113) //获得指纹模板数量
(0114) void FINGERPRINT_Cmd_Get_Templete_Num(void)
(0115) {
(0116) 	unsigned int i;
(0117) 	unsigned char temp[14];
(0118) 
(0119) 	for(i=0;i<6;i++) //包头
    0027C 2744      CLR	R20
    0027D 2755      CLR	R21
    0027E C00A      RJMP	0x0289
(0120) 		UART1_Send_Byte(FP_Pack_Head[i]);
    0027F E08F      LDI	R24,0xF
    00280 E091      LDI	R25,1
    00281 01FA      MOVW	R30,R20
    00282 0FE8      ADD	R30,R24
    00283 1FF9      ADC	R31,R25
    00284 8100      LD	R16,Z
    00285 940E 013B CALL	_USART1_Transmit
    00287 5F4F      SUBI	R20,0xFF
    00288 4F5F      SBCI	R21,0xFF
    00289 3046      CPI	R20,6
    0028A E0E0      LDI	R30,0
    0028B 075E      CPC	R21,R30
    0028C F390      BCS	0x027F
(0121) 
(0122) 	for(i=0;i<6;i++) //发送命令0x1d
    0028D 2744      CLR	R20
    0028E 2755      CLR	R21
    0028F C00A      RJMP	0x029A
(0123) 		UART1_Send_Byte(FP_Templete_Num[i]);
    00290 E18B      LDI	R24,0x1B
    00291 E091      LDI	R25,1
    00292 01FA      MOVW	R30,R20
    00293 0FE8      ADD	R30,R24
    00294 1FF9      ADC	R31,R25
    00295 8100      LD	R16,Z
    00296 940E 013B CALL	_USART1_Transmit
    00298 5F4F      SUBI	R20,0xFF
    00299 4F5F      SBCI	R21,0xFF
    0029A 3046      CPI	R20,6
    0029B E0E0      LDI	R30,0
    0029C 075E      CPC	R21,R30
    0029D F390      BCS	0x0290
    0029E 962E      ADIW	R28,0xE
    0029F 9159      LD	R21,Y+
    002A0 9149      LD	R20,Y+
    002A1 9508      RET
_FINGERPRINT_Cmd_Search_Finger:
  i                    --> R20
    002A2 934A      ST	-Y,R20
(0124) }
(0125) 
(0126) //搜索全部用户999枚
(0127) void FINGERPRINT_Cmd_Search_Finger(void)
(0128) {
(0129) 	unsigned char i;
(0130) 
(0131) 	for(i=0;i<6;i++) //发送命令搜索指纹库
    002A3 2744      CLR	R20
    002A4 C00A      RJMP	0x02AF
(0132) 		UART1_Send_Byte(FP_Pack_Head[i]);
    002A5 E08F      LDI	R24,0xF
    002A6 E091      LDI	R25,1
    002A7 2FE4      MOV	R30,R20
    002A8 27FF      CLR	R31
    002A9 0FE8      ADD	R30,R24
    002AA 1FF9      ADC	R31,R25
    002AB 8100      LD	R16,Z
    002AC 940E 013B CALL	_USART1_Transmit
    002AE 9543      INC	R20
    002AF 3046      CPI	R20,6
    002B0 F3A0      BCS	0x02A5
(0133) 
(0134) 	for(i=0;i<11;i++)
    002B1 2744      CLR	R20
    002B2 C00A      RJMP	0x02BD
(0135) 		UART1_Send_Byte(FP_Search[i]);
    002B3 E281      LDI	R24,0x21
    002B4 E091      LDI	R25,1
    002B5 2FE4      MOV	R30,R20
    002B6 27FF      CLR	R31
    002B7 0FE8      ADD	R30,R24
    002B8 1FF9      ADC	R31,R25
    002B9 8100      LD	R16,Z
    002BA 940E 013B CALL	_USART1_Transmit
    002BC 9543      INC	R20
    002BD 304B      CPI	R20,0xB
    002BE F3A0      BCS	0x02B3
    002BF 9149      LD	R20,Y+
    002C0 9508      RET
_FINGERPRINT_Cmd_Search_Finger_Admin:
  i                    --> R20
    002C1 934A      ST	-Y,R20
(0136) }
(0137) 
(0138) //搜索管理员用户10枚
(0139) void FINGERPRINT_Cmd_Search_Finger_Admin(void)
(0140) {
(0141) 	unsigned char i;
(0142) 
(0143) 	for(i=0;i<6;i++) //发送命令搜索指纹库
    002C2 2744      CLR	R20
    002C3 C00A      RJMP	0x02CE
(0144) 		UART1_Send_Byte(FP_Pack_Head[i]);
    002C4 E08F      LDI	R24,0xF
    002C5 E091      LDI	R25,1
    002C6 2FE4      MOV	R30,R20
    002C7 27FF      CLR	R31
    002C8 0FE8      ADD	R30,R24
    002C9 1FF9      ADC	R31,R25
    002CA 8100      LD	R16,Z
    002CB 940E 013B CALL	_USART1_Transmit
    002CD 9543      INC	R20
    002CE 3046      CPI	R20,6
    002CF F3A0      BCS	0x02C4
(0145) 
(0146) 	for(i=0;i<11;i++)
    002D0 2744      CLR	R20
    002D1 C00A      RJMP	0x02DC
(0147) 		UART1_Send_Byte(FP_Search_0_9[i]);
    002D2 E28C      LDI	R24,0x2C
    002D3 E091      LDI	R25,1
    002D4 2FE4      MOV	R30,R20
    002D5 27FF      CLR	R31
    002D6 0FE8      ADD	R30,R24
    002D7 1FF9      ADC	R31,R25
    002D8 8100      LD	R16,Z
    002D9 940E 013B CALL	_USART1_Transmit
    002DB 9543      INC	R20
    002DC 304B      CPI	R20,0xB
    002DD F3A0      BCS	0x02D2
    002DE 9149      LD	R20,Y+
    002DF 9508      RET
_FINGERPRINT_Cmd_Save_Finger:
  sum                  --> Y,+0
  i                    --> R10
  Page_ID              --> R10
    002E0 940E 0566 CALL	push_xgsetF00C
    002E2 0158      MOVW	R10,R16
    002E3 9724      SBIW	R28,4
(0148) }
(0149) 
(0150) //保存指纹到指定的位置
(0151) void FINGERPRINT_Cmd_Save_Finger(unsigned int Page_ID)
(0152) {
(0153) 	unsigned long sum = 0;
    002E4 E080      LDI	R24,0
    002E5 8388      ST	Y,R24
    002E6 8389      STD	Y+1,R24
    002E7 838A      STD	Y+2,R24
    002E8 838B      STD	Y+3,R24
(0154) 	unsigned char i;
(0155) 
(0156) 	//SAVE_FINGER[9]={0x01,0x00,0x06,0x06,0x01,0x00,0x0B,0x00,0x19}; //将BUFFER1中的特征码存放到指定的位置
(0157) 
(0158) 	FP_Save_Finger[5] = (Page_ID & 0xFF00) >> 8;
    002E9 01C5      MOVW	R24,R10
    002EA 7080      ANDI	R24,0
    002EB 011C      MOVW	R2,R24
    002EC 2C23      MOV	R2,R3
    002ED 2433      CLR	R3
    002EE 9220 0156 STS	FP_Save_Finger+5,R2
(0159) 	FP_Save_Finger[6] = (Page_ID & 0x00FF);
    002F0 01C5      MOVW	R24,R10
    002F1 7090      ANDI	R25,0
    002F2 9380 0157 STS	FP_Save_Finger+6,R24
(0160) 
(0161) 	for(i=0;i<7;i++) //计算校验和
    002F4 24AA      CLR	R10
    002F5 C017      RJMP	0x030D
(0162) 		sum = sum + FP_Save_Finger[i];
    002F6 E581      LDI	R24,0x51
    002F7 E091      LDI	R25,1
    002F8 2DEA      MOV	R30,R10
    002F9 27FF      CLR	R31
    002FA 0FE8      ADD	R30,R24
    002FB 1FF9      ADC	R31,R25
    002FC 8020      LD	R2,Z
    002FD 2433      CLR	R3
    002FE 2444      CLR	R4
    002FF 2455      CLR	R5
    00300 8068      LD	R6,Y
    00301 8079      LDD	R7,Y+1
    00302 808A      LDD	R8,Y+2
    00303 809B      LDD	R9,Y+3
    00304 0C62      ADD	R6,R2
    00305 1C73      ADC	R7,R3
    00306 1C84      ADC	R8,R4
    00307 1C95      ADC	R9,R5
    00308 8268      ST	Y,R6
    00309 8279      STD	Y+1,R7
    0030A 828A      STD	Y+2,R8
    0030B 829B      STD	Y+3,R9
    0030C 94A3      INC	R10
    0030D 2D8A      MOV	R24,R10
    0030E 3087      CPI	R24,7
    0030F F330      BCS	0x02F6
(0163) 
(0164) 	FP_Save_Finger[7]=(sum & 0x00FF00) >> 8; //存放校验数据
    00310 E040      LDI	R20,0
    00311 EF5F      LDI	R21,0xFF
    00312 E060      LDI	R22,0
    00313 E070      LDI	R23,0
    00314 8108      LD	R16,Y
    00315 8119      LDD	R17,Y+1
    00316 812A      LDD	R18,Y+2
    00317 813B      LDD	R19,Y+3
    00318 2304      AND	R16,R20
    00319 2315      AND	R17,R21
    0031A 2326      AND	R18,R22
    0031B 2337      AND	R19,R23
    0031C E088      LDI	R24,0x8
    0031D E090      LDI	R25,0
    0031E 938A      ST	-Y,R24
    0031F 940E 0574 CALL	lsr32
    00321 9300 0158 STS	FP_Save_Finger+7,R16
(0165) 	FP_Save_Finger[8]= sum & 0x0000FF;
    00323 EF4F      LDI	R20,0xFF
    00324 E050      LDI	R21,0
    00325 E060      LDI	R22,0
    00326 E070      LDI	R23,0
    00327 8028      LD	R2,Y
    00328 8039      LDD	R3,Y+1
    00329 804A      LDD	R4,Y+2
    0032A 805B      LDD	R5,Y+3
    0032B 2224      AND	R2,R20
    0032C 2235      AND	R3,R21
    0032D 2246      AND	R4,R22
    0032E 2257      AND	R5,R23
    0032F 9220 0159 STS	FP_Save_Finger+8,R2
(0166) 
(0167) 	for(i=0;i<6;i++)
    00331 24AA      CLR	R10
    00332 C00A      RJMP	0x033D
(0168) 		UART1_Send_Byte(FP_Pack_Head[i]); //发送包头
    00333 E08F      LDI	R24,0xF
    00334 E091      LDI	R25,1
    00335 2DEA      MOV	R30,R10
    00336 27FF      CLR	R31
    00337 0FE8      ADD	R30,R24
    00338 1FF9      ADC	R31,R25
    00339 8100      LD	R16,Z
    0033A 940E 013B CALL	_USART1_Transmit
    0033C 94A3      INC	R10
    0033D 2D8A      MOV	R24,R10
    0033E 3086      CPI	R24,6
    0033F F398      BCS	0x0333
(0169) 
(0170) 	for(i=0;i<9;i++)
    00340 24AA      CLR	R10
    00341 C00A      RJMP	0x034C
(0171) 		UART1_Send_Byte(FP_Save_Finger[i]); //发送命令将图像转换成特征码存放在CHAR_buffer1
    00342 E581      LDI	R24,0x51
    00343 E091      LDI	R25,1
    00344 2DEA      MOV	R30,R10
    00345 27FF      CLR	R31
    00346 0FE8      ADD	R30,R24
    00347 1FF9      ADC	R31,R25
    00348 8100      LD	R16,Z
    00349 940E 013B CALL	_USART1_Transmit
    0034B 94A3      INC	R10
    0034C 2D8A      MOV	R24,R10
    0034D 3089      CPI	R24,0x9
    0034E F398      BCS	0x0342
    0034F 9624      ADIW	R28,4
    00350 940C 056D JMP	pop_xgsetF00C
_FINGERPRINT_Recevice_Data:
  i                    --> R10
  ucLength             --> R12
    00352 92AA      ST	-Y,R10
    00353 92CA      ST	-Y,R12
    00354 2EC0      MOV	R12,R16
(0172) }
(0173) 
(0174) //接收反馈数据缓冲
(0175) void FINGERPRINT_Recevice_Data(unsigned char ucLength)
(0176) {
(0177) 	unsigned char i;
(0178) 
(0179) 	for (i=0;i<ucLength;i++)
    00355 24AA      CLR	R10
    00356 C00A      RJMP	0x0361
(0180) 		UART1_FINGERPRINT_RECEVICE_BUFFER[i] = UART1_Receive_Byte();
    00357 940E 0155 CALL	_USART1_Receive
    00359 E781      LDI	R24,0x71
    0035A E091      LDI	R25,1
    0035B 2DEA      MOV	R30,R10
    0035C 27FF      CLR	R31
    0035D 0FE8      ADD	R30,R24
    0035E 1FF9      ADC	R31,R25
    0035F 8300      ST	Z,R16
    00360 94A3      INC	R10
    00361 14AC      CP	R10,R12
    00362 F3A0      BCS	0x0357
    00363 90C9      LD	R12,Y+
    00364 90A9      LD	R10,Y+
    00365 9508      RET
_FINGERPRINT_add_new_user:
  Page_ID              --> R10
    00366 92AA      ST	-Y,R10
    00367 92BA      ST	-Y,R11
    00368 0158      MOVW	R10,R16
(0181) }
(0182) 
(0183) /*-------------------- 应用层接口函数 --------------------*/
(0184) 
(0185) //指纹添加新用户
(0186) unsigned char FINGERPRINT_add_new_user(unsigned int Page_ID)
(0187) {
(0188) 	led_off_all(); //先关闭所有提示灯
    00369 940E 0525 CALL	_led_off_all
(0189) 	led_on(1); //打开第一个提示灯
    0036B E001      LDI	R16,1
    0036C 940E 04DB CALL	_led_on
(0190) 
(0191) 	do
(0192) 	{
(0193) 		FINGERPRINT_Cmd_Get_Img(); //获得指纹图像
    0036E DE1D      RCALL	_FINGERPRINT_Cmd_Get_Img
(0194) 		FINGERPRINT_Recevice_Data(12); //接收12个长度的反馈码
    0036F E00C      LDI	R16,0xC
    00370 DFE1      RCALL	_FINGERPRINT_Recevice_Data
(0195) 	}
(0196) 	while(UART1_FINGERPRINT_RECEVICE_BUFFER[9]!=0x00); //检测是否成功的按了指纹
    00371 9020 017A LDS	R2,UART1_FINGERPRINT_RECEVICE_BUFFER+9
    00373 2022      TST	R2
    00374 F7C9      BNE	0x036E
(0197) 	
(0198) 	led_on(2); //第一个指纹录入完成, 打开第二个提示灯
    00375 E002      LDI	R16,2
    00376 940E 04DB CALL	_led_on
(0199) 
(0200) 	FINGERPRINT_Cmd_Img_To_Buffer1(); //将图像转换成特征码存放在Buffer1中
    00378 DE32      RCALL	_FINGERPRINT_Cmd_Img_To_Buffer1
(0201) 	FINGERPRINT_Recevice_Data(12); //接收12个长度的反馈码
    00379 E00C      LDI	R16,0xC
    0037A DFD7      RCALL	_FINGERPRINT_Recevice_Data
(0202) 
(0203) 	do
(0204) 	{
(0205) 		FINGERPRINT_Cmd_Get_Img(); //获得指纹图像
    0037B DE10      RCALL	_FINGERPRINT_Cmd_Get_Img
(0206) 		FINGERPRINT_Recevice_Data(12); //接收12个长度的反馈码			 
    0037C E00C      LDI	R16,0xC
    0037D DFD4      RCALL	_FINGERPRINT_Recevice_Data
(0207) 	}
(0208) 	while(UART1_FINGERPRINT_RECEVICE_BUFFER[9]!=0x00);
    0037E 9020 017A LDS	R2,UART1_FINGERPRINT_RECEVICE_BUFFER+9
    00380 2022      TST	R2
    00381 F7C9      BNE	0x037B
(0209) 	
(0210) 	led_on(3); //第二个指纹录入完成, 打开第三个提示灯
    00382 E003      LDI	R16,3
    00383 940E 04DB CALL	_led_on
(0211) 
(0212) 	FINGERPRINT_Cmd_Img_To_Buffer2(); //将图像转换成特征码存放在Buffer2中
    00385 DE44      RCALL	_FINGERPRINT_Cmd_Img_To_Buffer2
(0213) 	FINGERPRINT_Recevice_Data(12); //接收12个长度的反馈码
    00386 E00C      LDI	R16,0xC
    00387 DFCA      RCALL	_FINGERPRINT_Recevice_Data
(0214) 
(0215) 	FINGERPRINT_Cmd_Reg_Model(); //转换成特征码
    00388 DE60      RCALL	_FINGERPRINT_Cmd_Reg_Model
(0216) 	FINGERPRINT_Recevice_Data(12);
    00389 E00C      LDI	R16,0xC
    0038A DFC7      RCALL	_FINGERPRINT_Recevice_Data
(0217) 	if(UART1_FINGERPRINT_RECEVICE_BUFFER[9]!=0x00)
    0038B 9020 017A LDS	R2,UART1_FINGERPRINT_RECEVICE_BUFFER+9
    0038D 2022      TST	R2
    0038E F011      BEQ	0x0391
(0218) 		return 0; //合并特征生成模板出错 返回0
    0038F 2700      CLR	R16
    00390 C014      RJMP	0x03A5
(0219) 
(0220) 	FINGERPRINT_Cmd_Save_Finger(Page_ID);
    00391 0185      MOVW	R16,R10
    00392 DF4D      RCALL	_FINGERPRINT_Cmd_Save_Finger
(0221) 	FINGERPRINT_Recevice_Data(12);
    00393 E00C      LDI	R16,0xC
    00394 DFBD      RCALL	_FINGERPRINT_Recevice_Data
(0222) 	if(UART1_FINGERPRINT_RECEVICE_BUFFER[9]!=0x00)
    00395 9020 017A LDS	R2,UART1_FINGERPRINT_RECEVICE_BUFFER+9
    00397 2022      TST	R2
    00398 F041      BEQ	0x03A1
(0223) 	{
(0224) 		if(UART1_FINGERPRINT_RECEVICE_BUFFER[9]==0x0B)
    00399 9180 017A LDS	R24,UART1_FINGERPRINT_RECEVICE_BUFFER+9
    0039B 308B      CPI	R24,0xB
    0039C F411      BNE	0x039F
(0225) 			return 2; //PageID超出指纹库范围 返回2
    0039D E002      LDI	R16,2
    0039E C006      RJMP	0x03A5
(0226) 		return 0; //储存模板出错 返回0
    0039F 2700      CLR	R16
    003A0 C004      RJMP	0x03A5
(0227) 	}
(0228) 
(0229) 	led_on(4); //添加新用户完成, 打开全部提示灯
    003A1 E004      LDI	R16,4
    003A2 940E 04DB CALL	_led_on
(0230) 	return 1; //全部执行无误 返回1
    003A4 E001      LDI	R16,1
    003A5 90B9      LD	R11,Y+
    003A6 90A9      LD	R10,Y+
    003A7 9508      RET
(0231) }
(0232) 
(0233) //指纹搜索是否为注册用户
(0234) unsigned char FINGERPRINT_search_reg_user(void)
(0235) {
(0236) 	led_off_all(); //先关闭所有提示灯
_FINGERPRINT_search_reg_user:
    003A8 940E 0525 CALL	_led_off_all
(0237) 	led_on(1); //打开第一个提示灯
    003AA E001      LDI	R16,1
    003AB 940E 04DB CALL	_led_on
(0238) 
(0239) 	do
(0240) 	{
(0241) 		FINGERPRINT_Cmd_Get_Img(); //获得指纹图像
    003AD DDDE      RCALL	_FINGERPRINT_Cmd_Get_Img
(0242) 		FINGERPRINT_Recevice_Data(12); //接收12个长度的反馈码
    003AE E00C      LDI	R16,0xC
    003AF DFA2      RCALL	_FINGERPRINT_Recevice_Data
(0243) 	}
(0244) 	while(UART1_FINGERPRINT_RECEVICE_BUFFER[9]!=0x00); //检测是否成功的按了指纹
    003B0 9020 017A LDS	R2,UART1_FINGERPRINT_RECEVICE_BUFFER+9
    003B2 2022      TST	R2
    003B3 F7C9      BNE	0x03AD
(0245) 	
(0246) 	led_on(2); //读取到指纹, 打开第二个提示灯
    003B4 E002      LDI	R16,2
    003B5 940E 04DB CALL	_led_on
(0247) 	
(0248) 	FINGERPRINT_Cmd_Img_To_Buffer1(); //将图像转换成特征码存放在Buffer1中
    003B7 DDF3      RCALL	_FINGERPRINT_Cmd_Img_To_Buffer1
(0249) 	FINGERPRINT_Recevice_Data(12); //接收12个长度的反馈码
    003B8 E00C      LDI	R16,0xC
    003B9 DF98      RCALL	_FINGERPRINT_Recevice_Data
(0250) 	
(0251) 	FINGERPRINT_Cmd_Search_Finger(); //搜索全部用户999枚
    003BA DEE7      RCALL	_FINGERPRINT_Cmd_Search_Finger
(0252) 	FINGERPRINT_Recevice_Data(16); //接收16个长度的反馈码
    003BB E100      LDI	R16,0x10
    003BC DF95      RCALL	_FINGERPRINT_Recevice_Data
(0253) 	if(UART1_FINGERPRINT_RECEVICE_BUFFER[9]!=0x00)
    003BD 9020 017A LDS	R2,UART1_FINGERPRINT_RECEVICE_BUFFER+9
    003BF 2022      TST	R2
    003C0 F059      BEQ	0x03CC
(0254) 	{
(0255) 		led_on(3); //发生错误, 打开第三个提示灯
    003C1 E003      LDI	R16,3
    003C2 940E 04DB CALL	_led_on
(0256) 		
(0257) 		if(UART1_FINGERPRINT_RECEVICE_BUFFER[9]==0x09)
    003C4 9180 017A LDS	R24,UART1_FINGERPRINT_RECEVICE_BUFFER+9
    003C6 3089      CPI	R24,0x9
    003C7 F411      BNE	0x03CA
(0258) 			return 2; //没搜索到 返回2
    003C8 E002      LDI	R16,2
    003C9 C003      RJMP	0x03CD
(0259) 		return 0; //其他错误 返回0
    003CA 2700      CLR	R16
    003CB C001      RJMP	0x03CD
(0260) 	}
(0261) 
(0262) 	led_on_all; //找到匹配的指纹, 打开全部提示灯
(0263) 	return 1; //全部执行无误 返回1
    003CC E001      LDI	R16,1
    003CD 9508      RET
FILE: F:\工作\单片机\WorkSpace\AccessControlSystem\LCD_Operate.c
(0001) //LCD_Operate.c
(0002) 
(0003) #include <iom128v.h>
(0004) #include <macros.h>
(0005) #include "LCD_Operate.h"
(0006) #include "USART_Operate.h"
(0007) #include "GlobalDefine.h"
(0008) 
(0009) //LCD测忙
(0010) unsigned char LCD_Busy(void)
(0011) {
(0012) 	if(lcd_busy)
(0013) 		return 1;
_LCD_Busy:
    003CE E001      LDI	R16,1
    003CF C001      RJMP	0x03D1
(0014) 	else
(0015) 		return 0;
    003D0 2700      CLR	R16
    003D1 9508      RET
_LCD_Clear_Screen:
  color                --> R10
    003D2 92AA      ST	-Y,R10
    003D3 92BA      ST	-Y,R11
    003D4 0158      MOVW	R10,R16
(0016) }
(0017) 
(0018) //LCD用color颜色清屏
(0019) void LCD_Clear_Screen(unsigned char *color)
(0020) {
(0021) 	USART0_Transmit_String("CLS(");
    003D5 E60C      LDI	R16,0x6C
    003D6 E011      LDI	R17,1
    003D7 940E 0113 CALL	_USART0_Transmit_String
(0022) 	USART0_Transmit_String(color);
    003D9 0185      MOVW	R16,R10
    003DA 940E 0113 CALL	_USART0_Transmit_String
(0023) 	USART0_Transmit_String(");\r\n");
    003DC E607      LDI	R16,0x67
    003DD E011      LDI	R17,1
    003DE 940E 0113 CALL	_USART0_Transmit_String
    003E0 90B9      LD	R11,Y+
    003E1 90A9      LD	R10,Y+
    003E2 9508      RET
(0024) }
(0025) 
(0026) //LCD显示
(0027) void LCD_Display(void)
(0028) {
(0029) 	USART0_Transmit_String("\r\n");
_LCD_Display:
    003E3 E604      LDI	R16,0x64
    003E4 E011      LDI	R17,1
    003E5 940C 0113 JMP	_USART0_Transmit_String
_Keyboard_Scan:
  key                  --> R20
  temp                 --> R22
    003E7 940E 0566 CALL	push_xgsetF00C
FILE: F:\工作\单片机\WorkSpace\AccessControlSystem\KeyboardOperate.c
(0001) //KeyboardOperate.c
(0002) 
(0003) #include <iom128v.h>
(0004) #include <macros.h>
(0005) #include "KeyboardOperate.h"
(0006) #include "GlobalDefine.h"
(0007) 
(0008) //判断按下的是哪个按键
(0009) unsigned char Keyboard_Scan(void)
(0010) {
(0011) 	unsigned char temp; //设置PB口读取寄存位
(0012) 	unsigned char key = 0; //设置按键值寄存位(初值为0, 可以用于判断是否有按键按下)
    003E9 2744      CLR	R20
(0013) 	
(0014) 	//检测第一行按键
(0015) 	PORTB = 0xFE; //PB0以外全设为高电平
    003EA EF8E      LDI	R24,0xFE
    003EB BB88      OUT	0x18,R24
(0016) 	DDRB  = 0x0F; //PB低四位设为输入
    003EC E08F      LDI	R24,0xF
    003ED BB87      OUT	0x17,R24
(0017) 	temp  = PINB; //读出PB口的数值到temp
    003EE B366      IN	R22,0x16
(0018) 	temp &= 0xF0; //检查高四位
    003EF 7F60      ANDI	R22,0xF0
(0019) 	if(temp != 0xF0) //若高四位不全是高电平, 说明有按键按下
    003F0 3F60      CPI	R22,0xF0
    003F1 F179      BEQ	0x0421
(0020) 	{
(0021) 		delay(1); //消抖
    003F2 E001      LDI	R16,1
    003F3 940E 04C5 CALL	_delay
(0022) 		temp  = PINB; //读出PB口的数值到temp
    003F5 B366      IN	R22,0x16
(0023) 		temp &= 0xF0; //再次检查高四位的电平
    003F6 7F60      ANDI	R22,0xF0
(0024) 		if(temp != 0xF0) //若高四位还不全是高电平, 说明确实有按键按下
    003F7 3F60      CPI	R22,0xF0
    003F8 F141      BEQ	0x0421
(0025) 		{
(0026) 			temp = PINB; //读出PB口的数值到temp
    003F9 B366      IN	R22,0x16
(0027) 			switch(temp) //判断是哪个按键按下
    003FA 2EA6      MOV	R10,R22
    003FB 24BB      CLR	R11
    003FC 01C5      MOVW	R24,R10
    003FD 3B8E      CPI	R24,0xBE
    003FE E0E0      LDI	R30,0
    003FF 079E      CPC	R25,R30
    00400 F0E9      BEQ	0x041E
    00401 EB8E      LDI	R24,0xBE
    00402 158A      CP	R24,R10
    00403 059B      CPC	R25,R11
    00404 F034      BLT	0x040B
    00405 01C5      MOVW	R24,R10
    00406 378E      CPI	R24,0x7E
    00407 E0E0      LDI	R30,0
    00408 079E      CPC	R25,R30
    00409 F0B1      BEQ	0x0420
    0040A C016      RJMP	0x0421
    0040B 01C5      MOVW	R24,R10
    0040C 3D8E      CPI	R24,0xDE
    0040D E0E0      LDI	R30,0
    0040E 079E      CPC	R25,R30
    0040F F061      BEQ	0x041C
    00410 3D8E      CPI	R24,0xDE
    00411 E0E0      LDI	R30,0
    00412 079E      CPC	R25,R30
    00413 F06C      BLT	0x0421
    00414 01C5      MOVW	R24,R10
    00415 3E8E      CPI	R24,0xEE
    00416 E0E0      LDI	R30,0
    00417 079E      CPC	R25,R30
    00418 F009      BEQ	0x041A
    00419 C007      RJMP	0x0421
(0028) 			{
(0029) 				case 0xEE: key = '1'; break;
    0041A E341      LDI	R20,0x31
    0041B C005      RJMP	0x0421
(0030) 				case 0xDE: key = '2'; break;
    0041C E342      LDI	R20,0x32
    0041D C003      RJMP	0x0421
(0031) 				case 0xBE: key = '3'; break;
    0041E E343      LDI	R20,0x33
    0041F C001      RJMP	0x0421
(0032) 				case 0x7E: key = 'A'; break;
    00420 E441      LDI	R20,0x41
(0033) 			}
(0034) 		}
(0035) 		//while(temp != 0xF0); //松手检测
(0036) 	}
(0037) 	
(0038) 	//检测第二行按键
(0039) 	PORTB = 0xFD; //PB1以外全设为高电平
    00421 EF8D      LDI	R24,0xFD
    00422 BB88      OUT	0x18,R24
(0040) 	DDRB  = 0x0F; //PB低四位设为输入
    00423 E08F      LDI	R24,0xF
    00424 BB87      OUT	0x17,R24
(0041) 	temp  = PINB; //读出PB口的数值到temp
    00425 B366      IN	R22,0x16
(0042) 	temp &= 0xF0; //检查高四位
    00426 7F60      ANDI	R22,0xF0
(0043) 	if(temp != 0xF0) //若高四位不全是高电平, 说明有按键按下
    00427 3F60      CPI	R22,0xF0
    00428 F179      BEQ	0x0458
(0044) 	{
(0045) 		delay(1); //消抖
    00429 E001      LDI	R16,1
    0042A 940E 04C5 CALL	_delay
(0046) 		temp  = PINB; //读出PB口的数值到temp
    0042C B366      IN	R22,0x16
(0047) 		temp &= 0xF0; //再次检查高四位的电平
    0042D 7F60      ANDI	R22,0xF0
(0048) 		if(temp != 0xF0) //若高四位还不全是高电平, 说明确实有按键按下
    0042E 3F60      CPI	R22,0xF0
    0042F F141      BEQ	0x0458
(0049) 		{
(0050) 			temp = PINB; //读出PB口的数值到temp
    00430 B366      IN	R22,0x16
(0051) 			switch(temp) //判断是哪个按键按下
    00431 2EA6      MOV	R10,R22
    00432 24BB      CLR	R11
    00433 01C5      MOVW	R24,R10
    00434 3B8D      CPI	R24,0xBD
    00435 E0E0      LDI	R30,0
    00436 079E      CPC	R25,R30
    00437 F0E9      BEQ	0x0455
    00438 EB8D      LDI	R24,0xBD
    00439 158A      CP	R24,R10
    0043A 059B      CPC	R25,R11
    0043B F034      BLT	0x0442
    0043C 01C5      MOVW	R24,R10
    0043D 378D      CPI	R24,0x7D
    0043E E0E0      LDI	R30,0
    0043F 079E      CPC	R25,R30
    00440 F0B1      BEQ	0x0457
    00441 C016      RJMP	0x0458
    00442 01C5      MOVW	R24,R10
    00443 3D8D      CPI	R24,0xDD
    00444 E0E0      LDI	R30,0
    00445 079E      CPC	R25,R30
    00446 F061      BEQ	0x0453
    00447 3D8D      CPI	R24,0xDD
    00448 E0E0      LDI	R30,0
    00449 079E      CPC	R25,R30
    0044A F06C      BLT	0x0458
    0044B 01C5      MOVW	R24,R10
    0044C 3E8D      CPI	R24,0xED
    0044D E0E0      LDI	R30,0
    0044E 079E      CPC	R25,R30
    0044F F009      BEQ	0x0451
    00450 C007      RJMP	0x0458
(0052) 			{
(0053) 				case 0xED: key = '4'; break;
    00451 E344      LDI	R20,0x34
    00452 C005      RJMP	0x0458
(0054) 				case 0xDD: key = '5'; break;
    00453 E345      LDI	R20,0x35
    00454 C003      RJMP	0x0458
(0055) 				case 0xBD: key = '6'; break;
    00455 E346      LDI	R20,0x36
    00456 C001      RJMP	0x0458
(0056) 				case 0x7D: key = 'B'; break;
    00457 E442      LDI	R20,0x42
(0057) 			}
(0058) 		}
(0059) 		//while(temp != 0xF0); //松手检测
(0060) 	}
(0061) 	
(0062) 	//检测第三行按键
(0063) 	PORTB = 0xFB; //PB2以外全设为高电平
    00458 EF8B      LDI	R24,0xFB
    00459 BB88      OUT	0x18,R24
(0064) 	DDRB  = 0x0F; //PB低四位设为输入
    0045A E08F      LDI	R24,0xF
    0045B BB87      OUT	0x17,R24
(0065) 	temp  = PINB; //读出PB口的数值到temp
    0045C B366      IN	R22,0x16
(0066) 	temp &= 0xF0; //检查高四位
    0045D 7F60      ANDI	R22,0xF0
(0067) 	if(temp != 0xF0) //若高四位不全是高电平, 说明有按键按下
    0045E 3F60      CPI	R22,0xF0
    0045F F179      BEQ	0x048F
(0068) 	{
(0069) 		delay(1); //消抖
    00460 E001      LDI	R16,1
    00461 940E 04C5 CALL	_delay
(0070) 		temp  = PINB; //读出PB口的数值到temp
    00463 B366      IN	R22,0x16
(0071) 		temp &= 0xF0; //再次检查高四位的电平
    00464 7F60      ANDI	R22,0xF0
(0072) 		if(temp != 0xF0) //若高四位还不全是高电平, 说明确实有按键按下
    00465 3F60      CPI	R22,0xF0
    00466 F141      BEQ	0x048F
(0073) 		{
(0074) 			temp = PINB; //读出PB口的数值到temp
    00467 B366      IN	R22,0x16
(0075) 			switch(temp) //判断是哪个按键按下
    00468 2EA6      MOV	R10,R22
    00469 24BB      CLR	R11
    0046A 01C5      MOVW	R24,R10
    0046B 3B8B      CPI	R24,0xBB
    0046C E0E0      LDI	R30,0
    0046D 079E      CPC	R25,R30
    0046E F0E9      BEQ	0x048C
    0046F EB8B      LDI	R24,0xBB
    00470 158A      CP	R24,R10
    00471 059B      CPC	R25,R11
    00472 F034      BLT	0x0479
    00473 01C5      MOVW	R24,R10
    00474 378B      CPI	R24,0x7B
    00475 E0E0      LDI	R30,0
    00476 079E      CPC	R25,R30
    00477 F0B1      BEQ	0x048E
    00478 C016      RJMP	0x048F
    00479 01C5      MOVW	R24,R10
    0047A 3D8B      CPI	R24,0xDB
    0047B E0E0      LDI	R30,0
    0047C 079E      CPC	R25,R30
    0047D F061      BEQ	0x048A
    0047E 3D8B      CPI	R24,0xDB
    0047F E0E0      LDI	R30,0
    00480 079E      CPC	R25,R30
    00481 F06C      BLT	0x048F
    00482 01C5      MOVW	R24,R10
    00483 3E8B      CPI	R24,0xEB
    00484 E0E0      LDI	R30,0
    00485 079E      CPC	R25,R30
    00486 F009      BEQ	0x0488
    00487 C007      RJMP	0x048F
(0076) 			{
(0077) 				case 0xEB: key = '7'; break;
    00488 E347      LDI	R20,0x37
    00489 C005      RJMP	0x048F
(0078) 				case 0xDB: key = '8'; break;
    0048A E348      LDI	R20,0x38
    0048B C003      RJMP	0x048F
(0079) 				case 0xBB: key = '9'; break;
    0048C E349      LDI	R20,0x39
    0048D C001      RJMP	0x048F
(0080) 				case 0x7B: key = 'C'; break;
    0048E E443      LDI	R20,0x43
(0081) 			}
(0082) 		}
(0083) 		//while(temp != 0xF0); //松手检测
(0084) 	}
(0085) 	
(0086) 	//检测第四行按键
(0087) 	PORTB = 0xF7; //PB3以外全设为高电平
    0048F EF87      LDI	R24,0xF7
    00490 BB88      OUT	0x18,R24
(0088) 	DDRB  = 0x0F; //PB低四位设为输入
    00491 E08F      LDI	R24,0xF
    00492 BB87      OUT	0x17,R24
(0089) 	temp  = PINB; //读出PB口的数值到temp
    00493 B366      IN	R22,0x16
(0090) 	temp &= 0xF0; //检查高四位
    00494 7F60      ANDI	R22,0xF0
(0091) 	if(temp != 0xF0) //若高四位不全是高电平, 说明有按键按下
    00495 3F60      CPI	R22,0xF0
    00496 F159      BEQ	0x04C2
(0092) 	{
(0093) 		delay(1); //消抖
    00497 E001      LDI	R16,1
    00498 940E 04C5 CALL	_delay
(0094) 		temp  = PINB; //读出PB口的数值到temp
    0049A B366      IN	R22,0x16
(0095) 		temp &= 0xF0; //再次检查高四位的电平
    0049B 7F60      ANDI	R22,0xF0
(0096) 		if(temp != 0xF0) //若高四位还不全是高电平, 说明确实有按键按下
    0049C 3F60      CPI	R22,0xF0
    0049D F121      BEQ	0x04C2
(0097) 		{
(0098) 			temp = PINB; //读出PB口的数值到temp
    0049E B366      IN	R22,0x16
(0099) 			switch(temp) //判断是哪个按键按下
    0049F 2777      CLR	R23
    004A0 3B67      CPI	R22,0xB7
    004A1 E0E0      LDI	R30,0
    004A2 077E      CPC	R23,R30
    004A3 F0D9      BEQ	0x04BF
    004A4 EB87      LDI	R24,0xB7
    004A5 E090      LDI	R25,0
    004A6 1786      CP	R24,R22
    004A7 0797      CPC	R25,R23
    004A8 F02C      BLT	0x04AE
    004A9 3767      CPI	R22,0x77
    004AA E0E0      LDI	R30,0
    004AB 077E      CPC	R23,R30
    004AC F0A1      BEQ	0x04C1
    004AD C014      RJMP	0x04C2
    004AE 3D67      CPI	R22,0xD7
    004AF E0E0      LDI	R30,0
    004B0 077E      CPC	R23,R30
    004B1 F059      BEQ	0x04BD
    004B2 3D67      CPI	R22,0xD7
    004B3 E0E0      LDI	R30,0
    004B4 077E      CPC	R23,R30
    004B5 F064      BLT	0x04C2
    004B6 3E67      CPI	R22,0xE7
    004B7 E0E0      LDI	R30,0
    004B8 077E      CPC	R23,R30
    004B9 F009      BEQ	0x04BB
    004BA C007      RJMP	0x04C2
(0100) 			{
(0101) 				case 0xE7: key = '*'; break;
    004BB E24A      LDI	R20,0x2A
    004BC C005      RJMP	0x04C2
(0102) 				case 0xD7: key = '0'; break;
    004BD E340      LDI	R20,0x30
    004BE C003      RJMP	0x04C2
(0103) 				case 0xB7: key = '#'; break;
    004BF E243      LDI	R20,0x23
    004C0 C001      RJMP	0x04C2
(0104) 				case 0x77: key = 'D'; break;
    004C1 E444      LDI	R20,0x44
(0105) 			}
(0106) 		}
(0107) 		//while(temp != 0xF0); //松手检测
(0108) 	}
(0109) 	return key; //返回读到的按键值
    004C2 2F04      MOV	R16,R20
    004C3 940C 056D JMP	pop_xgsetF00C
_delay:
  j                    --> R20
  k                    --> R22
  i                    --> R16
    004C5 934A      ST	-Y,R20
    004C6 936A      ST	-Y,R22
FILE: F:\工作\单片机\WorkSpace\AccessControlSystem\GlobalDefine.c
(0001) //GlobalDefine.c
(0002) 
(0003) #include <iom128v.h>
(0004) #include <macros.h>
(0005) #include "GlobalDefine.h"
(0006) 
(0007) //延时函数
(0008) void delay(unsigned char i)
(0009) {
(0010) 	unsigned char j, k;
(0011) 	
(0012) 	for(i; i>0; i--)
    004C7 C00D      RJMP	0x04D5
(0013) 		for(j=0xFF; j>0; j--)
    004C8 EF4F      LDI	R20,0xFF
    004C9 C007      RJMP	0x04D1
(0014) 			for(k=0xFF; k>0; k--);
    004CA EF6F      LDI	R22,0xFF
    004CB C001      RJMP	0x04CD
    004CC 956A      DEC	R22
    004CD E080      LDI	R24,0
    004CE 1786      CP	R24,R22
    004CF F3E0      BCS	0x04CC
    004D0 954A      DEC	R20
    004D1 E080      LDI	R24,0
    004D2 1784      CP	R24,R20
    004D3 F3B0      BCS	0x04CA
    004D4 950A      DEC	R16
    004D5 E080      LDI	R24,0
    004D6 1780      CP	R24,R16
    004D7 F380      BCS	0x04C8
    004D8 9169      LD	R22,Y+
    004D9 9149      LD	R20,Y+
    004DA 9508      RET
_led_on:
  i                    --> R16
    004DB 934A      ST	-Y,R20
    004DC 935A      ST	-Y,R21
(0015) }
(0016) 
(0017) //点亮指定LED
(0018) void led_on(unsigned char i)
(0019) {
(0020) 	switch(i)
    004DD 2F40      MOV	R20,R16
    004DE 2755      CLR	R21
    004DF 3041      CPI	R20,1
    004E0 E0E0      LDI	R30,0
    004E1 075E      CPC	R21,R30
    004E2 F069      BEQ	0x04F0
    004E3 3042      CPI	R20,2
    004E4 E0E0      LDI	R30,0
    004E5 075E      CPC	R21,R30
    004E6 F061      BEQ	0x04F3
    004E7 3043      CPI	R20,3
    004E8 E0E0      LDI	R30,0
    004E9 075E      CPC	R21,R30
    004EA F059      BEQ	0x04F6
    004EB 3044      CPI	R20,4
    004EC E0E0      LDI	R30,0
    004ED 075E      CPC	R21,R30
    004EE F051      BEQ	0x04F9
    004EF C00B      RJMP	0x04FB
(0021) 	{
(0022) 		case 1:
(0023) 			PORTA |= BIT(0);
    004F0 9AD8      SBI	0x1B,0
(0024) 			DDRA  |= BIT(0);
    004F1 9AD0      SBI	0x1A,0
(0025) 			break;
    004F2 C008      RJMP	0x04FB
(0026) 		case 2:
(0027) 			PORTA |= BIT(1);
    004F3 9AD9      SBI	0x1B,1
(0028) 			DDRA  |= BIT(1);
    004F4 9AD1      SBI	0x1A,1
(0029) 			break;
    004F5 C005      RJMP	0x04FB
(0030) 		case 3:
(0031) 			PORTA |= BIT(2);
    004F6 9ADA      SBI	0x1B,2
(0032) 			DDRA  |= BIT(2);
    004F7 9AD2      SBI	0x1A,2
(0033) 			break;
    004F8 C002      RJMP	0x04FB
(0034) 		case 4:
(0035) 			PORTA |= BIT(3);
    004F9 9ADB      SBI	0x1B,3
(0036) 			DDRA  |= BIT(3);
    004FA 9AD3      SBI	0x1A,3
(0037) 			break;
    004FB 9159      LD	R21,Y+
    004FC 9149      LD	R20,Y+
    004FD 9508      RET
_led_off:
  i                    --> R16
    004FE 934A      ST	-Y,R20
    004FF 935A      ST	-Y,R21
(0038) 	}
(0039) }
(0040) 
(0041) //熄灭指定LED
(0042) void led_off(unsigned char i)
(0043) {
(0044) 	switch(i)
    00500 2F40      MOV	R20,R16
    00501 2755      CLR	R21
    00502 3041      CPI	R20,1
    00503 E0E0      LDI	R30,0
    00504 075E      CPC	R21,R30
    00505 F069      BEQ	0x0513
    00506 3042      CPI	R20,2
    00507 E0E0      LDI	R30,0
    00508 075E      CPC	R21,R30
    00509 F061      BEQ	0x0516
    0050A 3043      CPI	R20,3
    0050B E0E0      LDI	R30,0
    0050C 075E      CPC	R21,R30
    0050D F059      BEQ	0x0519
    0050E 3044      CPI	R20,4
    0050F E0E0      LDI	R30,0
    00510 075E      CPC	R21,R30
    00511 F051      BEQ	0x051C
    00512 C00B      RJMP	0x051E
(0045) 	{
(0046) 		case 1:
(0047) 			PORTA &=~BIT(0);
    00513 98D8      CBI	0x1B,0
(0048) 			DDRA  &=~BIT(0);
    00514 98D0      CBI	0x1A,0
(0049) 			break;
    00515 C008      RJMP	0x051E
(0050) 		case 2:
(0051) 			PORTA &=~BIT(1);
    00516 98D9      CBI	0x1B,1
(0052) 			DDRA  &=~BIT(1);
    00517 98D1      CBI	0x1A,1
(0053) 			break;
    00518 C005      RJMP	0x051E
(0054) 		case 3:
(0055) 			PORTA &=~BIT(2);
    00519 98DA      CBI	0x1B,2
(0056) 			DDRA  &=~BIT(2);
    0051A 98D2      CBI	0x1A,2
(0057) 			break;
    0051B C002      RJMP	0x051E
(0058) 		case 4:
(0059) 			PORTA &=~BIT(3);
    0051C 98DB      CBI	0x1B,3
(0060) 			DDRA  &=~BIT(3);
    0051D 98D3      CBI	0x1A,3
(0061) 			break;
    0051E 9159      LD	R21,Y+
    0051F 9149      LD	R20,Y+
    00520 9508      RET
(0062) 	}
(0063) }
(0064) 
(0065) //点亮全部LED
(0066) void led_on_all(void)
(0067) {
(0068) 	PORTA = 0x0F;
_led_on_all:
    00521 E08F      LDI	R24,0xF
    00522 BB8B      OUT	0x1B,R24
(0069) 	DDRA  = 0x0F;
    00523 BB8A      OUT	0x1A,R24
    00524 9508      RET
(0070) }
(0071) 
(0072) //熄灭全部LED
(0073) void led_off_all(void)
(0074) {
(0075) 	PORTA = 0x00;
_led_off_all:
    00525 2422      CLR	R2
    00526 BA2B      OUT	0x1B,R2
(0076) 	DDRA  = 0x0F;
    00527 E08F      LDI	R24,0xF
    00528 BB8A      OUT	0x1A,R24
    00529 9508      RET
_led_blink:
  i                    --> R10
    0052A 92AA      ST	-Y,R10
    0052B 2EA0      MOV	R10,R16
(0077) }
(0078) 
(0079) //LED闪烁指定次
(0080) void led_blink(unsigned char i)
(0081) {
(0082) 	for(i; i>0; i--)
    0052C C007      RJMP	0x0534
(0083) 	{
(0084) 		led_on_all();
    0052D DFF3      RCALL	_led_on_all
(0085) 		delay(10);
    0052E E00A      LDI	R16,0xA
    0052F DF95      RCALL	_delay
(0086) 		led_off_all();
    00530 DFF4      RCALL	_led_off_all
(0087) 		delay(10);
    00531 E00A      LDI	R16,0xA
    00532 DF92      RCALL	_delay
    00533 94AA      DEC	R10
    00534 E080      LDI	R24,0
    00535 158A      CP	R24,R10
    00536 F3B0      BCS	0x052D
    00537 90A9      LD	R10,Y+
    00538 9508      RET
FILE: F:\工作\单片机\WorkSpace\AccessControlSystem\DeviceInitialize.c
(0001) //DeviceInitialize.c
(0002) 
(0003) #include <iom128v.h>
(0004) #include <macros.h>
(0005) #include "DeviceInitialize.h"
(0006) #include "USART_Operate.h"
(0007) 
(0008) //IO端口初始化
(0009) void port_init(void)
(0010) {
(0011) 	PORTA = 0x00;
_port_init:
    00539 2422      CLR	R2
    0053A BA2B      OUT	0x1B,R2
(0012) 	DDRA  = 0x00;
    0053B BA2A      OUT	0x1A,R2
(0013) 	PORTB = 0x00;
    0053C BA28      OUT	0x18,R2
(0014) 	DDRB  = 0x00;
    0053D BA27      OUT	0x17,R2
(0015) 	PORTC = 0x00; //仅当m103输出
    0053E BA25      OUT	0x15,R2
(0016) 	DDRC  = 0x00;
    0053F BA24      OUT	0x14,R2
(0017) 	PORTD = 0x00;
    00540 BA22      OUT	0x12,R2
(0018) 	DDRD  = 0x00;
    00541 BA21      OUT	0x11,R2
(0019) 	PORTE = 0x00;
    00542 B823      OUT	0x03,R2
(0020) 	DDRE  = 0x00;
    00543 B822      OUT	0x02,R2
(0021) 	PORTF = 0x00;
    00544 9220 0062 STS	0x62,R2
(0022) 	DDRF  = 0x00;
    00546 9220 0061 STS	0x61,R2
(0023) 	PORTG = 0x00;
    00548 9220 0065 STS	0x65,R2
(0024) 	DDRG  = 0x00;
    0054A 9220 0064 STS	0x64,R2
    0054C 9508      RET
(0025) }
(0026) 
(0027) //设备初始化
(0028) void init_devices(void)
(0029) {
(0030) 	//停止错误中断直到设置好
(0031) 	CLI(); //禁用所有中断
_init_devices:
    0054D 94F8      BCLR	7
(0032) 	XDIV  = 0x00; //晶振驱动
    0054E 2422      CLR	R2
    0054F BE2C      OUT	0x3C,R2
(0033) 	XMCRA = 0x00; //外部存储器
    00550 9220 006D STS	0x6D,R2
(0034) 	port_init(); //IO端口初始化
    00552 DFE6      RCALL	_port_init
(0035) 	USART0_Init(MYUBRR0); //USART0串口初始化
    00553 E005      LDI	R16,5
    00554 E010      LDI	R17,0
    00555 940E 00E1 CALL	_USART0_Init
(0036) 	USART1_Init(MYUBRR1); //USART1串口初始化
    00557 E00B      LDI	R16,0xB
    00558 E010      LDI	R17,0
    00559 940E 0128 CALL	_USART1_Init
(0037) 
(0038) 	MCUCR = 0x00;
    0055B 2422      CLR	R2
    0055C BE25      OUT	0x35,R2
(0039) 	EICRA = 0x00; //设置外部中断控制寄存器
    0055D 9220 006A STS	0x6A,R2
(0040) 	EICRB = 0x00; //设置外部中断控制寄存器
    0055F BE2A      OUT	0x3A,R2
(0041) 	EIMSK = 0x00;
    00560 BE29      OUT	0x39,R2
(0042) 	TIMSK = 0x00; //定时器中断源
    00561 BE27      OUT	0x37,R2
(0043) 	ETIMSK = 0x00; //扩展定时器中断源
    00562 9220 007D STS	0x7D,R2
(0044) 	SEI(); //重新启用中断
FILE: <library>
    00564 9478      BSET	7
    00565 9508      RET
push_xgsetF00C:
    00566 937A      ST	-Y,R23
    00567 936A      ST	-Y,R22
    00568 935A      ST	-Y,R21
    00569 934A      ST	-Y,R20
    0056A 92BA      ST	-Y,R11
    0056B 92AA      ST	-Y,R10
    0056C 9508      RET
pop_xgsetF00C:
    0056D 90A9      LD	R10,Y+
    0056E 90B9      LD	R11,Y+
    0056F 9149      LD	R20,Y+
    00570 9159      LD	R21,Y+
    00571 9169      LD	R22,Y+
    00572 9179      LD	R23,Y+
    00573 9508      RET
lsr32:
    00574 920F      PUSH	R0
    00575 9009      LD	R0,Y+
    00576 2000      TST	R0
    00577 F031      BEQ	0x057E
    00578 9536      LSR	R19
    00579 9527      ROR	R18
    0057A 9517      ROR	R17
    0057B 9507      ROR	R16
    0057C 940A      DEC	R0
    0057D CFF8      RJMP	0x0576
    0057E 900F      POP	R0
    0057F 9508      RET
