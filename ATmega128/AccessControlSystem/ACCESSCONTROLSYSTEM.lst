Interrupt Vectors
    00000 940C 0078 JMP	__start|__text_start

Program Code (text area)
__start|__text_start:
    00078 EFCF      LDI	R28,0xFF
    00079 E1D0      LDI	R29,0x10
    0007A BFCD      OUT	0x3D,R28
    0007B BFDE      OUT	0x3E,R29
    0007C 51CE      SUBI	R28,0x1E
    0007D 40D0      SBCI	R29,0
    0007E EA0A      LDI	R16,0xAA
    0007F 8308      ST	Y,R16
    00080 2400      CLR	R0
    00081 E6E3      LDI	R30,0x63
    00082 E0F1      LDI	R31,1
    00083 E011      LDI	R17,1
    00084 37EB      CPI	R30,0x7B
    00085 07F1      CPC	R31,R17
    00086 F011      BEQ	0x0089
    00087 9201      ST	Z+,R0
    00088 CFFB      RJMP	0x0084
    00089 8300      ST	Z,R16
    0008A E8EC      LDI	R30,0x8C
    0008B E0F0      LDI	R31,0
    0008C E0A0      LDI	R26,0
    0008D E0B1      LDI	R27,1
    0008E E010      LDI	R17,0
    0008F E000      LDI	R16,0
    00090 BF0B      OUT	0x3B,R16
    00091 3EEF      CPI	R30,0xEF
    00092 07F1      CPC	R31,R17
    00093 F021      BEQ	0x0098
    00094 95C8      LPM
    00095 9631      ADIW	R30,1
    00096 920D      ST	X+,R0
    00097 CFF9      RJMP	0x0091
    00098 940E 00AE CALL	_main
_exit:
    0009A CFFF      RJMP	_exit
_delay:
  i                    --> R20
  ms                   --> R16
    0009B 934A      ST	-Y,R20
    0009C 935A      ST	-Y,R21
FILE: F:\工作\单片机\WorkSpace\AccessControlSystem\AccessControlSystem.c
(0001) #include <iom128v.h>
(0002) #include <macros.h>
(0003) #include "USART_Operate.h"
(0004) #include "FingerprintOperate.h"
(0005) #include "LCD_Operate.h"
(0006) #include "KeyboardOperate.h"
(0007) #include "GlobalDefine.h"
(0008) 
(0009) #define uart0_send_string USART0_Transmit_String
(0010) 
(0011) void delay(unsigned int ms)
(0012) {
(0013) 	unsigned int i;
(0014) 	for(ms;ms>0;ms--)
    0009D C00A      RJMP	0x00A8
(0015) 		for(i=1200;i>0;i--);
    0009E EB40      LDI	R20,0xB0
    0009F E054      LDI	R21,4
    000A0 C002      RJMP	0x00A3
    000A1 5041      SUBI	R20,1
    000A2 4050      SBCI	R21,0
    000A3 3040      CPI	R20,0
    000A4 0745      CPC	R20,R21
    000A5 F7D9      BNE	0x00A1
    000A6 5001      SUBI	R16,1
    000A7 4010      SBCI	R17,0
    000A8 3000      CPI	R16,0
    000A9 0701      CPC	R16,R17
    000AA F799      BNE	0x009E
    000AB 9159      LD	R21,Y+
    000AC 9149      LD	R20,Y+
    000AD 9508      RET
(0016) }
(0017) 
(0018) void main(void)
(0019) {
(0020) 	USART0_Init(MYUBRR0);
_main:
    000AE E005      LDI	R16,5
    000AF E010      LDI	R17,0
    000B0 940E 00D8 CALL	_USART0_Init
(0021) 	PORTA = 0x81;
    000B2 E881      LDI	R24,0x81
    000B3 BB8B      OUT	0x1B,R24
(0022)  	DDRA  = 0x81;
    000B4 BB8A      OUT	0x1A,R24
    000B5 C020      RJMP	0x00D6
(0023) 	
(0024) 	//FINGERPRINT_add_new_user(0x00,0x0B);
(0025) 	
(0026) 	while(1)
(0027) 	{
(0028) 		while(LCD_Busy());
    000B6 940E 0373 CALL	_LCD_Busy
    000B8 2300      TST	R16
    000B9 F7E1      BNE	0x00B6
(0029) 		LCD_Clear_Screen(cyan);
    000BA E002      LDI	R16,2
    000BB E011      LDI	R17,1
    000BC 940E 0379 CALL	_LCD_Clear_Screen
(0030) 		//uart0_send_string("DS32(0,50,'实验室门禁系统',1);DS16(65,100,'显示模块测试',2);\r\n");
(0031) 		while(LCD_Busy());
    000BE 940E 0373 CALL	_LCD_Busy
    000C0 2300      TST	R16
    000C1 F7E1      BNE	0x00BE
(0032) 		delay(5000);
    000C2 E808      LDI	R16,0x88
    000C3 E113      LDI	R17,0x13
    000C4 DFD6      RCALL	_delay
(0033) 		while(LCD_Busy());
    000C5 940E 0373 CALL	_LCD_Busy
    000C7 2EA0      MOV	R10,R16
    000C8 2300      TST	R16
    000C9 F7D9      BNE	0x00C5
(0034) 		LCD_Clear_Screen(gray);
    000CA E000      LDI	R16,0
    000CB E011      LDI	R17,1
    000CC 940E 0379 CALL	_LCD_Clear_Screen
(0035) 		//uart0_send_string("DS32(0,50,'实验室门禁系统',1);DS16(65,100,'显示模块测试',2);\r\n");
(0036) 		while(LCD_Busy());
    000CE 940E 0373 CALL	_LCD_Busy
    000D0 2EA0      MOV	R10,R16
    000D1 2300      TST	R16
    000D2 F7D9      BNE	0x00CE
(0037) 		delay(5000);
    000D3 E808      LDI	R16,0x88
    000D4 E113      LDI	R17,0x13
    000D5 DFC5      RCALL	_delay
    000D6 CFDF      RJMP	0x00B6
    000D7 9508      RET
FILE: F:\工作\单片机\WorkSpace\AccessControlSystem\USART_Operate.c
(0001) //USART_Operate.c
(0002) 
(0003) #include <iom128v.h>
(0004) #include "USART_Operate.h"
(0005) 
(0006) //USART0初始化
(0007) void USART0_Init(unsigned int ubrr)
(0008) {
(0009) 	UBRR0H = (unsigned char)(ubrr>>8); //设置波特率
_USART0_Init:
  ubrr                 --> R16
    000D8 0118      MOVW	R2,R16
    000D9 2C23      MOV	R2,R3
    000DA 2433      CLR	R3
    000DB 9220 0090 STS	0x90,R2
(0010) 	UBRR0L = (unsigned char)ubrr;
    000DD B909      OUT	0x09,R16
(0011) 	UCSR0B = (1<<RXEN0)|(1<<TXEN0); //使能接收器与发送器
    000DE E188      LDI	R24,0x18
    000DF B98A      OUT	0x0A,R24
(0012) 	UCSR0C = (1<<USBS0)|(3<<UCSZ00); //设置帧格式: 8个数据位, 2个停止位
    000E0 E08E      LDI	R24,0xE
    000E1 9380 0095 STS	0x95,R24
    000E3 9508      RET
(0013) }
(0014) 
(0015) //USART0以5到8个数据位的方式发送帧
(0016) void USART0_Transmit(unsigned char data)
(0017) {
(0018) 	while(!(UCSR0A & (1<<UDRE0))); //等待发送缓冲器为空
_USART0_Transmit:
  data                 --> R16
    000E4 9B5D      SBIS	0x0B,5
    000E5 CFFE      RJMP	_USART0_Transmit
(0019) 	UDR0 = data; //将数据放入缓冲器, 发送数据
    000E6 B90C      OUT	0x0C,R16
    000E7 9508      RET
(0020) }
(0021) 
(0022) //USART0以9个数据位的方式发送帧
(0023) void USART0_Transmit_9bits(unsigned int data)
(0024) {
(0025) 	while(!(UCSR0A & (1<<UDRE0))); //等待发送缓冲器为空
_USART0_Transmit_9bits:
  data                 --> R16
    000E8 9B5D      SBIS	0x0B,5
    000E9 CFFE      RJMP	_USART0_Transmit_9bits
(0026) 	UCSR0B &= ~(1<<TXB80); //将第9位复制到TXB8
    000EA 9850      CBI	0x0A,0
(0027) 	if(data & 0x0100)
    000EB FF10      SBRS	R17,0
    000EC C001      RJMP	0x00EE
(0028) 		UCSR0B |= (1<<TXB80);
    000ED 9A50      SBI	0x0A,0
(0029) 	UDR0 = data; //将数据放入缓冲器, 发送数据
    000EE B90C      OUT	0x0C,R16
    000EF 9508      RET
(0030) }
(0031) 
(0032) //USART0以5到8个数据位的方式接收帧
(0033) unsigned char USART0_Receive(void)
(0034) {
(0035) 	while(!(UCSR0A & (1<<RXC0))); //等待接收数据
_USART0_Receive:
    000F0 9B5F      SBIS	0x0B,7
    000F1 CFFE      RJMP	_USART0_Receive
(0036) 	return UDR0; //从缓冲器中获取并返回数据
    000F2 B10C      IN	R16,0x0C
    000F3 9508      RET
_USART0_Receive_9bits:
  resl                 --> R18
  status               --> R20
  resh                 --> R16
    000F4 934A      ST	-Y,R20
(0037) }
(0038) 
(0039) //USART0以9个数据位的方式接收帧
(0040) unsigned int USART0_Receive_9bits(void)
(0041) {
(0042) 	unsigned char status, resh, resl;
(0043) 
(0044) 	while(!(UCSR0A & (1<<RXC0))); //等待接收数据
    000F5 9B5F      SBIS	0x0B,7
    000F6 CFFE      RJMP	0x00F5
(0045) 	status = UCSR0A; //从缓冲器中获得状态、第9位及数据
    000F7 B14B      IN	R20,0x0B
(0046) 	resh = UCSR0B;
    000F8 B10A      IN	R16,0x0A
(0047) 	resl = UDR0;
    000F9 B12C      IN	R18,0x0C
(0048) 	if(status & (1<<FE0) | (1<<DOR0) | (1<<UPE0)) //如果出错, 返回-1
    000FA 2F84      MOV	R24,R20
    000FB 7180      ANDI	R24,0x10
    000FC 608C      ORI	R24,0xC
    000FD F019      BEQ	0x0101
(0049) 		return -1;
    000FE EF0F      LDI	R16,0xFF
    000FF EF1F      LDI	R17,0xFF
    00100 C004      RJMP	0x0105
(0050) 	resh = (resh >> 1) & 0x01; //过滤第9位数据, 然后返回
    00101 9506      LSR	R16
    00102 7001      ANDI	R16,1
(0051) 	return ((resh << 8) | resl);
    00103 2F10      MOV	R17,R16
    00104 2F02      MOV	R16,R18
    00105 9149      LD	R20,Y+
    00106 9508      RET
_USART0_Transmit_String:
  p                    --> R20
    00107 934A      ST	-Y,R20
    00108 935A      ST	-Y,R21
    00109 01A8      MOVW	R20,R16
(0052) }
(0053) 
(0054) //USART0以5到8个数据位的方式发送字符串
(0055) void USART0_Transmit_String(unsigned char *p)
(0056) {
    0010A C005      RJMP	0x0110
(0057)     while(*p)
(0058)     {
(0059)         USART0_Transmit(*p);
    0010B 01FA      MOVW	R30,R20
    0010C 8100      LD	R16,Z
    0010D DFD6      RCALL	_USART0_Transmit
(0060)         p++;
    0010E 5F4F      SUBI	R20,0xFF
    0010F 4F5F      SBCI	R21,0xFF
    00110 01FA      MOVW	R30,R20
    00111 8020      LD	R2,Z
    00112 2022      TST	R2
    00113 F7B9      BNE	0x010B
    00114 9159      LD	R21,Y+
    00115 9149      LD	R20,Y+
    00116 9508      RET
(0061)     }
(0062) }
(0063) 
(0064) //USART0刷新接收缓冲器
(0065) void USART0_Flush(void)
(0066) {
_USART0_Flush:
  dummy                --> R16
    00117 C001      RJMP	0x0119
(0067) 	unsigned char dummy;
(0068) 	while(UCSR0A & (1<<RXC0))
(0069) 		dummy = UDR0;
    00118 B10C      IN	R16,0x0C
    00119 995F      SBIC	0x0B,7
    0011A CFFD      RJMP	0x0118
    0011B 9508      RET
(0070) }
(0071) 
(0072) //USART1初始化
(0073) void USART1_Init(unsigned int ubrr)
(0074) {
(0075) 	UBRR1H = (unsigned char)(ubrr>>8); //设置波特率
_USART1_Init:
  ubrr                 --> R16
    0011C 0118      MOVW	R2,R16
    0011D 2C23      MOV	R2,R3
    0011E 2433      CLR	R3
    0011F 9220 0098 STS	0x98,R2
(0076) 	UBRR1L = (unsigned char)ubrr;
    00121 9300 0099 STS	0x99,R16
(0077) 	UCSR1B = (1<<RXEN1)|(1<<TXEN1); //使能接收器与发送器
    00123 E188      LDI	R24,0x18
    00124 9380 009A STS	0x9A,R24
(0078) 	UCSR1C = (1<<USBS1)|(3<<UCSZ01); //设置帧格式: 8个数据位, 2个停止位
    00126 E08C      LDI	R24,0xC
    00127 9380 009D STS	0x9D,R24
    00129 9508      RET
(0079) }
(0080) 
(0081) //USART1以5到8个数据位的方式发送帧
(0082) void USART1_Transmit(unsigned char data)
(0083) {
(0084) 	while(!(UCSR1A & (1<<UDRE1))); //等待发送缓冲器为空
_USART1_Transmit:
  data                 --> R16
    0012A 9020 009B LDS	R2,0x9B
    0012C FE25      SBRS	R2,5
    0012D CFFC      RJMP	_USART1_Transmit
(0085) 	UDR1 = data; //将数据放入缓冲器, 发送数据
    0012E 9300 009C STS	0x9C,R16
    00130 9508      RET
(0086) }
(0087) 
(0088) //USART1以9个数据位的方式发送帧
(0089) void USART1_Transmit_9bits(unsigned int data)
(0090) {
(0091) 	while(!(UCSR1A & (1<<UDRE1))); //等待发送缓冲器为空
_USART1_Transmit_9bits:
  data                 --> R16
    00131 9020 009B LDS	R2,0x9B
    00133 FE25      SBRS	R2,5
    00134 CFFC      RJMP	_USART1_Transmit_9bits
(0092) 	UCSR1B &= ~(1<<TXB81); //将第9位复制到TXB8
    00135 9180 009A LDS	R24,0x9A
    00137 7F8E      ANDI	R24,0xFE
    00138 9380 009A STS	0x9A,R24
(0093) 	if(data & 0x0100)
    0013A FF10      SBRS	R17,0
    0013B C005      RJMP	0x0141
(0094) 		UCSR1B |= (1<<TXB81);
    0013C 9180 009A LDS	R24,0x9A
    0013E 6081      ORI	R24,1
    0013F 9380 009A STS	0x9A,R24
(0095) 	UDR1 = data; //将数据放入缓冲器, 发送数据
    00141 9300 009C STS	0x9C,R16
    00143 9508      RET
(0096) }
(0097) 
(0098) //USART1以5到8个数据位的方式接收帧
(0099) unsigned char USART1_Receive(void)
(0100) {
(0101) 	while(!(UCSR1A & (1<<RXC1))); //等待接收数据
_USART1_Receive:
    00144 9020 009B LDS	R2,0x9B
    00146 FE27      SBRS	R2,7
    00147 CFFC      RJMP	_USART1_Receive
(0102) 	return UDR1; //从缓冲器中获取并返回数据
    00148 9100 009C LDS	R16,0x9C
    0014A 9508      RET
_USART1_Receive_9bits:
  resl                 --> R18
  status               --> R20
  resh                 --> R16
    0014B 934A      ST	-Y,R20
(0103) }
(0104) 
(0105) //USART1以9个数据位的方式接收帧
(0106) unsigned int USART1_Receive_9bits(void)
(0107) {
(0108) 	unsigned char status, resh, resl;
(0109) 
(0110) 	while(!(UCSR1A & (1<<RXC1))); //等待接收数据
    0014C 9020 009B LDS	R2,0x9B
    0014E FE27      SBRS	R2,7
    0014F CFFC      RJMP	0x014C
(0111) 	status = UCSR1A; //从缓冲器中获得状态、第9位及数据
    00150 9140 009B LDS	R20,0x9B
(0112) 	resh = UCSR1B;
    00152 9100 009A LDS	R16,0x9A
(0113) 	resl = UDR1;
    00154 9120 009C LDS	R18,0x9C
(0114) 	if(status & (1<<FE1) | (1<<DOR1) | (1<<UPE1)) //如果出错, 返回-1
    00156 2F84      MOV	R24,R20
    00157 7180      ANDI	R24,0x10
    00158 608C      ORI	R24,0xC
    00159 F019      BEQ	0x015D
(0115) 		return -1;
    0015A EF0F      LDI	R16,0xFF
    0015B EF1F      LDI	R17,0xFF
    0015C C004      RJMP	0x0161
(0116) 	resh = (resh >> 1) & 0x01; //过滤第9位数据, 然后返回
    0015D 9506      LSR	R16
    0015E 7001      ANDI	R16,1
(0117) 	return ((resh << 8) | resl);
    0015F 2F10      MOV	R17,R16
    00160 2F02      MOV	R16,R18
    00161 9149      LD	R20,Y+
    00162 9508      RET
_USART1_Transmit_String:
  p                    --> R20
    00163 934A      ST	-Y,R20
    00164 935A      ST	-Y,R21
    00165 01A8      MOVW	R20,R16
(0118) }
(0119) 
(0120) //USART1以5到8个数据位的方式发送字符串
(0121) void USART1_Transmit_String(unsigned char *p)
(0122) {
    00166 C005      RJMP	0x016C
(0123)     while(*p)
(0124)     {
(0125)         USART1_Transmit(*p);
    00167 01FA      MOVW	R30,R20
    00168 8100      LD	R16,Z
    00169 DFC0      RCALL	_USART1_Transmit
(0126)         p++;
    0016A 5F4F      SUBI	R20,0xFF
    0016B 4F5F      SBCI	R21,0xFF
    0016C 01FA      MOVW	R30,R20
    0016D 8020      LD	R2,Z
    0016E 2022      TST	R2
    0016F F7B9      BNE	0x0167
    00170 9159      LD	R21,Y+
    00171 9149      LD	R20,Y+
    00172 9508      RET
(0127)     }
(0128) }
(0129) 
(0130) //USART1刷新接收缓冲器
(0131) void USART1_Flush(void)
(0132) {
_USART1_Flush:
  dummy                --> R16
    00173 C002      RJMP	0x0176
(0133) 	unsigned char dummy;
(0134) 	while(UCSR1A & (1<<RXC1))
(0135) 		dummy = UDR1;
    00174 9100 009C LDS	R16,0x9C
    00176 9020 009B LDS	R2,0x9B
    00178 FC27      SBRC	R2,7
    00179 CFFA      RJMP	0x0174
    0017A 9508      RET
_FINGERPRINT_Cmd_Get_Img:
  i                    --> R20
    0017B 934A      ST	-Y,R20
FILE: F:\工作\单片机\WorkSpace\AccessControlSystem\FingerprintOperate.c
(0001) //FingerprintOperate.c
(0002) 
(0003) #include "FingerprintOperate.h"
(0004) #include "USART_Operate.h"
(0005) 
(0006) #define UART1_Send_Byte USART1_Transmit
(0007) #define UART1_Receive_Byte USART1_Receive
(0008) 
(0009) volatile unsigned char UART1_FINGERPRINT_RECEVICE_BUFFER[24];
(0010) 
(0011) //FINGERPRINT通信协议定义
(0012) unsigned char FP_Pack_Head[6]={0xEF,0x01,0xFF,0xFF,0xFF,0xFF}; //协议包头
(0013) unsigned char FP_Get_Img[6]={0x01,0x00,0x03,0x01,0x00,0x05}; //获得指纹图像
(0014) unsigned char FP_Templete_Num[6]={0x01,0x00,0x03,0x1D,0x00,0x21}; //获得模版总数
(0015) unsigned char FP_Search[11]={0x01,0x00,0x08,0x04,0x01,0x00,0x00,0x03,0xA1,0x00,0xB2}; //搜索指纹搜索范围0 - 929
(0016) unsigned char FP_Search_0_9[11]={0x01,0x00,0x08,0x04,0x01,0x00,0x00,0x00,0x13,0x00,0x21}; //搜索0-9号指纹
(0017) unsigned char FP_Img_To_Buffer1[7]={0x01,0x00,0x04,0x02,0x01,0x00,0x08}; //将图像放入到BUFFER1
(0018) unsigned char FP_Img_To_Buffer2[7]={0x01,0x00,0x04,0x02,0x02,0x00,0x09}; //将图像放入到BUFFER2
(0019) unsigned char FP_Reg_Model[6]={0x01,0x00,0x03,0x05,0x00,0x09}; //将BUFFER1跟BUFFER2合成特征模版
(0020) unsigned char FP_Delet_All_Model[6]={0x01,0x00,0x03,0x0d,0x00,0x11}; //删除指纹模块里所有的模版
(0021) volatile unsigned char FP_Save_Finger[9]={0x01,0x00,0x06,0x06,0x01,0x00,0x0B,0x00,0x19}; //将BUFFER1中的特征码存放到指定的位置
(0022) volatile unsigned char FP_Delete_Model[10]={0x01,0x00,0x07,0x0C,0x00,0x00,0x00,0x1,0x00,0x00}; //删除指定的模版
(0023) //volatile unsigned char FINGER_NUM;
(0024) 
(0025) /*------------------ FINGERPRINT命令字 --------------------------*/
(0026) 
(0027) //获得指纹图像命令
(0028) void FINGERPRINT_Cmd_Get_Img(void)
(0029) {
(0030) 	unsigned char i;
(0031) 
(0032) 	for(i=0;i<6;i++) //发送包头
    0017C 2744      CLR	R20
    0017D C00A      RJMP	0x0188
(0033) 		UART1_Send_Byte(FP_Pack_Head[i]);
    0017E E084      LDI	R24,4
    0017F E091      LDI	R25,1
    00180 2FE4      MOV	R30,R20
    00181 27FF      CLR	R31
    00182 0FE8      ADD	R30,R24
    00183 1FF9      ADC	R31,R25
    00184 8100      LD	R16,Z
    00185 940E 012A CALL	_USART1_Transmit
    00187 9543      INC	R20
    00188 3046      CPI	R20,6
    00189 F3A0      BCS	0x017E
(0034) 
(0035) 	for(i=0;i<6;i++) //发送命令0x1d
    0018A 2744      CLR	R20
    0018B C00A      RJMP	0x0196
(0036) 		UART1_Send_Byte(FP_Get_Img[i]);
    0018C E08A      LDI	R24,0xA
    0018D E091      LDI	R25,1
    0018E 2FE4      MOV	R30,R20
    0018F 27FF      CLR	R31
    00190 0FE8      ADD	R30,R24
    00191 1FF9      ADC	R31,R25
    00192 8100      LD	R16,Z
    00193 940E 012A CALL	_USART1_Transmit
    00195 9543      INC	R20
    00196 3046      CPI	R20,6
    00197 F3A0      BCS	0x018C
    00198 9149      LD	R20,Y+
    00199 9508      RET
_FINGERPRINT_Cmd_Img_To_Buffer1:
  i                    --> R20
    0019A 934A      ST	-Y,R20
(0037) }
(0038) 
(0039) //将图像转换成特征码存放在Buffer1中
(0040) void FINGERPRINT_Cmd_Img_To_Buffer1(void)
(0041) {
(0042) 	unsigned char i;
(0043) 
(0044) 	for(i=0;i<6;i++) //发送包头
    0019B 2744      CLR	R20
    0019C C00A      RJMP	0x01A7
(0045) 		UART1_Send_Byte(FP_Pack_Head[i]);
    0019D E084      LDI	R24,4
    0019E E091      LDI	R25,1
    0019F 2FE4      MOV	R30,R20
    001A0 27FF      CLR	R31
    001A1 0FE8      ADD	R30,R24
    001A2 1FF9      ADC	R31,R25
    001A3 8100      LD	R16,Z
    001A4 940E 012A CALL	_USART1_Transmit
    001A6 9543      INC	R20
    001A7 3046      CPI	R20,6
    001A8 F3A0      BCS	0x019D
(0046) 
(0047) 	for(i=0;i<7;i++) //发送命令将图像转换成特征码存放在CHAR_buffer1
    001A9 2744      CLR	R20
    001AA C00A      RJMP	0x01B5
(0048) 		UART1_Send_Byte(FP_Img_To_Buffer1[i]);
    001AB E28C      LDI	R24,0x2C
    001AC E091      LDI	R25,1
    001AD 2FE4      MOV	R30,R20
    001AE 27FF      CLR	R31
    001AF 0FE8      ADD	R30,R24
    001B0 1FF9      ADC	R31,R25
    001B1 8100      LD	R16,Z
    001B2 940E 012A CALL	_USART1_Transmit
    001B4 9543      INC	R20
    001B5 3047      CPI	R20,7
    001B6 F3A0      BCS	0x01AB
    001B7 9149      LD	R20,Y+
    001B8 9508      RET
_FINGERPRINT_Cmd_Img_To_Buffer2:
  i                    --> R20
    001B9 934A      ST	-Y,R20
(0049) }
(0050) 
(0051) //将图像转换成特征码存放在Buffer2中
(0052) void FINGERPRINT_Cmd_Img_To_Buffer2(void)
(0053) {
(0054) 	unsigned char i;
(0055) 
(0056) 	for(i=0;i<6;i++) //发送包头
    001BA 2744      CLR	R20
    001BB C00A      RJMP	0x01C6
(0057) 		UART1_Send_Byte(FP_Pack_Head[i]);
    001BC E084      LDI	R24,4
    001BD E091      LDI	R25,1
    001BE 2FE4      MOV	R30,R20
    001BF 27FF      CLR	R31
    001C0 0FE8      ADD	R30,R24
    001C1 1FF9      ADC	R31,R25
    001C2 8100      LD	R16,Z
    001C3 940E 012A CALL	_USART1_Transmit
    001C5 9543      INC	R20
    001C6 3046      CPI	R20,6
    001C7 F3A0      BCS	0x01BC
(0058) 
(0059) 	for(i=0;i<7;i++) //发送命令将图像转换成特征码存放在CHAR_buffer2
    001C8 2744      CLR	R20
    001C9 C00A      RJMP	0x01D4
(0060) 		UART1_Send_Byte(FP_Img_To_Buffer2[i]);
    001CA E383      LDI	R24,0x33
    001CB E091      LDI	R25,1
    001CC 2FE4      MOV	R30,R20
    001CD 27FF      CLR	R31
    001CE 0FE8      ADD	R30,R24
    001CF 1FF9      ADC	R31,R25
    001D0 8100      LD	R16,Z
    001D1 940E 012A CALL	_USART1_Transmit
    001D3 9543      INC	R20
    001D4 3047      CPI	R20,7
    001D5 F3A0      BCS	0x01CA
    001D6 9149      LD	R20,Y+
    001D7 9508      RET
_FINGERPRINT_Cmd_Reg_Model:
  i                    --> R20
    001D8 934A      ST	-Y,R20
(0061) }
(0062) 
(0063) //将BUFFER1跟BUFFER2中的特征码合并成指纹模版
(0064) void FINGERPRINT_Cmd_Reg_Model(void)
(0065) {
(0066) 	unsigned char i;
(0067) 
(0068) 	for(i=0;i<6;i++) //包头
    001D9 2744      CLR	R20
    001DA C00A      RJMP	0x01E5
(0069) 		UART1_Send_Byte(FP_Pack_Head[i]);
    001DB E084      LDI	R24,4
    001DC E091      LDI	R25,1
    001DD 2FE4      MOV	R30,R20
    001DE 27FF      CLR	R31
    001DF 0FE8      ADD	R30,R24
    001E0 1FF9      ADC	R31,R25
    001E1 8100      LD	R16,Z
    001E2 940E 012A CALL	_USART1_Transmit
    001E4 9543      INC	R20
    001E5 3046      CPI	R20,6
    001E6 F3A0      BCS	0x01DB
(0070) 
(0071) 	for(i=0;i<6;i++) //命令合并指纹模版
    001E7 2744      CLR	R20
    001E8 C00A      RJMP	0x01F3
(0072) 		UART1_Send_Byte(FP_Reg_Model[i]);
    001E9 E38A      LDI	R24,0x3A
    001EA E091      LDI	R25,1
    001EB 2FE4      MOV	R30,R20
    001EC 27FF      CLR	R31
    001ED 0FE8      ADD	R30,R24
    001EE 1FF9      ADC	R31,R25
    001EF 8100      LD	R16,Z
    001F0 940E 012A CALL	_USART1_Transmit
    001F2 9543      INC	R20
    001F3 3046      CPI	R20,6
    001F4 F3A0      BCS	0x01E9
    001F5 9149      LD	R20,Y+
    001F6 9508      RET
_FINGERPRINT_Cmd_Delete_All_Model:
  i                    --> R20
    001F7 934A      ST	-Y,R20
(0073) }
(0074) 
(0075) //删除指纹模块里的所有指纹模版
(0076) void FINGERPRINT_Cmd_Delete_All_Model(void)
(0077) {
(0078) 	unsigned char i;
(0079) 
(0080) 	for(i=0;i<6;i++) //包头
    001F8 2744      CLR	R20
    001F9 C00A      RJMP	0x0204
(0081) 		UART1_Send_Byte(FP_Pack_Head[i]);
    001FA E084      LDI	R24,4
    001FB E091      LDI	R25,1
    001FC 2FE4      MOV	R30,R20
    001FD 27FF      CLR	R31
    001FE 0FE8      ADD	R30,R24
    001FF 1FF9      ADC	R31,R25
    00200 8100      LD	R16,Z
    00201 940E 012A CALL	_USART1_Transmit
    00203 9543      INC	R20
    00204 3046      CPI	R20,6
    00205 F3A0      BCS	0x01FA
(0082) 
(0083) 	for(i=0;i<6;i++) //命令合并指纹模版
    00206 2744      CLR	R20
    00207 C00A      RJMP	0x0212
(0084) 		UART1_Send_Byte(FP_Delet_All_Model[i]);
    00208 E480      LDI	R24,0x40
    00209 E091      LDI	R25,1
    0020A 2FE4      MOV	R30,R20
    0020B 27FF      CLR	R31
    0020C 0FE8      ADD	R30,R24
    0020D 1FF9      ADC	R31,R25
    0020E 8100      LD	R16,Z
    0020F 940E 012A CALL	_USART1_Transmit
    00211 9543      INC	R20
    00212 3046      CPI	R20,6
    00213 F3A0      BCS	0x0208
    00214 9149      LD	R20,Y+
    00215 9508      RET
_FINGERPRINT_Cmd_Delete_Model:
  uiSum_temp           --> Y,+0
  i                    --> R20
  uiID_temp            --> R20
    00216 934A      ST	-Y,R20
    00217 935A      ST	-Y,R21
    00218 01A8      MOVW	R20,R16
    00219 9722      SBIW	R28,2
(0085) }
(0086) 
(0087) //删除指纹模块里的指定指纹模版
(0088) void FINGERPRINT_Cmd_Delete_Model(unsigned int uiID_temp)
(0089) {
(0090) 	volatile unsigned int uiSum_temp = 0;
    0021A 2422      CLR	R2
    0021B 2433      CLR	R3
    0021C 8239      STD	Y+1,R3
    0021D 8228      ST	Y,R2
(0091) 	unsigned char i;
(0092) 
(0093) 	FP_Delete_Model[4]=(uiID_temp&0xFF00)>>8;
    0021E 01CA      MOVW	R24,R20
    0021F 7080      ANDI	R24,0
    00220 2F89      MOV	R24,R25
    00221 2799      CLR	R25
    00222 9380 0153 STS	FP_Delete_Model+4,R24
(0094) 	FP_Delete_Model[5]=(uiID_temp&0x00FF);
    00224 01CA      MOVW	R24,R20
    00225 7090      ANDI	R25,0
    00226 9380 0154 STS	FP_Delete_Model+5,R24
(0095) 
(0096) 	for(i=0;i<8;i++)
    00228 2744      CLR	R20
    00229 C00F      RJMP	0x0239
(0097) 		uiSum_temp = uiSum_temp + FP_Delete_Model[i];
    0022A E48F      LDI	R24,0x4F
    0022B E091      LDI	R25,1
    0022C 2FE4      MOV	R30,R20
    0022D 27FF      CLR	R31
    0022E 0FE8      ADD	R30,R24
    0022F 1FF9      ADC	R31,R25
    00230 8020      LD	R2,Z
    00231 2433      CLR	R3
    00232 8048      LD	R4,Y
    00233 8059      LDD	R5,Y+1
    00234 0C42      ADD	R4,R2
    00235 1C53      ADC	R5,R3
    00236 8259      STD	Y+1,R5
    00237 8248      ST	Y,R4
    00238 9543      INC	R20
    00239 3048      CPI	R20,0x8
    0023A F378      BCS	0x022A
(0098) 	
(0099) 	//UART0_Send_Byte(uiSum_temp);
(0100) 			
(0101) 	FP_Delete_Model[8]=(uiSum_temp&0xFF00)>>8;
    0023B 8188      LD	R24,Y
    0023C 8199      LDD	R25,Y+1
    0023D 7080      ANDI	R24,0
    0023E 011C      MOVW	R2,R24
    0023F 2C23      MOV	R2,R3
    00240 2433      CLR	R3
    00241 9220 0157 STS	FP_Delete_Model+8,R2
(0102) 	FP_Delete_Model[9]=uiSum_temp&0x00FF;
    00243 8188      LD	R24,Y
    00244 8199      LDD	R25,Y+1
    00245 7090      ANDI	R25,0
    00246 9380 0158 STS	FP_Delete_Model+9,R24
(0103) 
(0104) 	for(i=0;i<6;i++) //包头
    00248 2744      CLR	R20
    00249 C00A      RJMP	0x0254
(0105) 		UART1_Send_Byte(FP_Pack_Head[i]);
    0024A E084      LDI	R24,4
    0024B E091      LDI	R25,1
    0024C 2FE4      MOV	R30,R20
    0024D 27FF      CLR	R31
    0024E 0FE8      ADD	R30,R24
    0024F 1FF9      ADC	R31,R25
    00250 8100      LD	R16,Z
    00251 940E 012A CALL	_USART1_Transmit
    00253 9543      INC	R20
    00254 3046      CPI	R20,6
    00255 F3A0      BCS	0x024A
(0106) 
(0107) 	for(i=0;i<10;i++) //命令合并指纹模版
    00256 2744      CLR	R20
    00257 C00A      RJMP	0x0262
(0108) 		UART1_Send_Byte(FP_Delete_Model[i]);
    00258 E48F      LDI	R24,0x4F
    00259 E091      LDI	R25,1
    0025A 2FE4      MOV	R30,R20
    0025B 27FF      CLR	R31
    0025C 0FE8      ADD	R30,R24
    0025D 1FF9      ADC	R31,R25
    0025E 8100      LD	R16,Z
    0025F 940E 012A CALL	_USART1_Transmit
    00261 9543      INC	R20
    00262 304A      CPI	R20,0xA
    00263 F3A0      BCS	0x0258
    00264 9622      ADIW	R28,2
    00265 9159      LD	R21,Y+
    00266 9149      LD	R20,Y+
    00267 9508      RET
_FINGERPRINT_Cmd_Get_Templete_Num:
  temp                 --> Y,+0
  i                    --> R20
    00268 934A      ST	-Y,R20
    00269 935A      ST	-Y,R21
    0026A 972E      SBIW	R28,0xE
(0109) }
(0110) 
(0111) //获得指纹模板数量
(0112) void FINGERPRINT_Cmd_Get_Templete_Num(void)
(0113) {
(0114) 	unsigned int i;
(0115) 	unsigned char temp[14];
(0116) 
(0117) 	for(i=0;i<6;i++) //包头
    0026B 2744      CLR	R20
    0026C 2755      CLR	R21
    0026D C00A      RJMP	0x0278
(0118) 		UART1_Send_Byte(FP_Pack_Head[i]);
    0026E E084      LDI	R24,4
    0026F E091      LDI	R25,1
    00270 01FA      MOVW	R30,R20
    00271 0FE8      ADD	R30,R24
    00272 1FF9      ADC	R31,R25
    00273 8100      LD	R16,Z
    00274 940E 012A CALL	_USART1_Transmit
    00276 5F4F      SUBI	R20,0xFF
    00277 4F5F      SBCI	R21,0xFF
    00278 3046      CPI	R20,6
    00279 E0E0      LDI	R30,0
    0027A 075E      CPC	R21,R30
    0027B F390      BCS	0x026E
(0119) 
(0120) 	for(i=0;i<6;i++) //发送命令0x1d
    0027C 2744      CLR	R20
    0027D 2755      CLR	R21
    0027E C00A      RJMP	0x0289
(0121) 		UART1_Send_Byte(FP_Templete_Num[i]);
    0027F E180      LDI	R24,0x10
    00280 E091      LDI	R25,1
    00281 01FA      MOVW	R30,R20
    00282 0FE8      ADD	R30,R24
    00283 1FF9      ADC	R31,R25
    00284 8100      LD	R16,Z
    00285 940E 012A CALL	_USART1_Transmit
    00287 5F4F      SUBI	R20,0xFF
    00288 4F5F      SBCI	R21,0xFF
    00289 3046      CPI	R20,6
    0028A E0E0      LDI	R30,0
    0028B 075E      CPC	R21,R30
    0028C F390      BCS	0x027F
    0028D 962E      ADIW	R28,0xE
    0028E 9159      LD	R21,Y+
    0028F 9149      LD	R20,Y+
    00290 9508      RET
_FINGERPRINT_Cmd_Search_Finger:
  i                    --> R20
    00291 934A      ST	-Y,R20
(0122) }
(0123) 
(0124) //搜索全部用户999枚
(0125) void FINGERPRINT_Cmd_Search_Finger(void)
(0126) {
(0127) 	unsigned char i;
(0128) 
(0129) 	for(i=0;i<6;i++) //发送命令搜索指纹库
    00292 2744      CLR	R20
    00293 C00A      RJMP	0x029E
(0130) 		UART1_Send_Byte(FP_Pack_Head[i]);
    00294 E084      LDI	R24,4
    00295 E091      LDI	R25,1
    00296 2FE4      MOV	R30,R20
    00297 27FF      CLR	R31
    00298 0FE8      ADD	R30,R24
    00299 1FF9      ADC	R31,R25
    0029A 8100      LD	R16,Z
    0029B 940E 012A CALL	_USART1_Transmit
    0029D 9543      INC	R20
    0029E 3046      CPI	R20,6
    0029F F3A0      BCS	0x0294
(0131) 
(0132) 	for(i=0;i<11;i++)
    002A0 2744      CLR	R20
    002A1 C00A      RJMP	0x02AC
(0133) 		UART1_Send_Byte(FP_Search[i]);
    002A2 E186      LDI	R24,0x16
    002A3 E091      LDI	R25,1
    002A4 2FE4      MOV	R30,R20
    002A5 27FF      CLR	R31
    002A6 0FE8      ADD	R30,R24
    002A7 1FF9      ADC	R31,R25
    002A8 8100      LD	R16,Z
    002A9 940E 012A CALL	_USART1_Transmit
    002AB 9543      INC	R20
    002AC 304B      CPI	R20,0xB
    002AD F3A0      BCS	0x02A2
    002AE 9149      LD	R20,Y+
    002AF 9508      RET
_FINGERPRINT_Cmd_Search_Finger_Admin:
  i                    --> R20
    002B0 934A      ST	-Y,R20
(0134) }
(0135) 
(0136) 
(0137) //搜索全部用户999枚
(0138) void FINGERPRINT_Cmd_Search_Finger_Admin(void)
(0139) {
(0140) 	unsigned char i;
(0141) 
(0142) 	for(i=0;i<6;i++) //发送命令搜索指纹库
    002B1 2744      CLR	R20
    002B2 C00A      RJMP	0x02BD
(0143) 		UART1_Send_Byte(FP_Pack_Head[i]);
    002B3 E084      LDI	R24,4
    002B4 E091      LDI	R25,1
    002B5 2FE4      MOV	R30,R20
    002B6 27FF      CLR	R31
    002B7 0FE8      ADD	R30,R24
    002B8 1FF9      ADC	R31,R25
    002B9 8100      LD	R16,Z
    002BA 940E 012A CALL	_USART1_Transmit
    002BC 9543      INC	R20
    002BD 3046      CPI	R20,6
    002BE F3A0      BCS	0x02B3
(0144) 
(0145) 	for(i=0;i<11;i++)
    002BF 2744      CLR	R20
    002C0 C00A      RJMP	0x02CB
(0146) 		UART1_Send_Byte(FP_Search_0_9[i]);
    002C1 E281      LDI	R24,0x21
    002C2 E091      LDI	R25,1
    002C3 2FE4      MOV	R30,R20
    002C4 27FF      CLR	R31
    002C5 0FE8      ADD	R30,R24
    002C6 1FF9      ADC	R31,R25
    002C7 8100      LD	R16,Z
    002C8 940E 012A CALL	_USART1_Transmit
    002CA 9543      INC	R20
    002CB 304B      CPI	R20,0xB
    002CC F3A0      BCS	0x02C1
    002CD 9149      LD	R20,Y+
    002CE 9508      RET
_FINGERPRINT_Cmd_Save_Finger:
  temp                 --> Y,+0
  i                    --> R10
  ucL_Char             --> R10
  ucH_Char             --> R12
    002CF 940E 038A CALL	push_xgsetF03C
    002D1 2EA2      MOV	R10,R18
    002D2 2EC0      MOV	R12,R16
    002D3 9724      SBIW	R28,4
(0147) }
(0148) 
(0149) void FINGERPRINT_Cmd_Save_Finger(unsigned char ucH_Char,unsigned char ucL_Char)
(0150) {
(0151) 	unsigned long temp = 0;
    002D4 E080      LDI	R24,0
    002D5 8388      ST	Y,R24
    002D6 8389      STD	Y+1,R24
    002D7 838A      STD	Y+2,R24
    002D8 838B      STD	Y+3,R24
(0152) 	unsigned char i;
(0153) 
(0154) 	//SAVE_FINGER[9]={0x01,0x00,0x06,0x06,0x01,0x00,0x0B,0x00,0x19}; //将BUFFER1中的特征码存放到指定的位置
(0155) 
(0156) 	FP_Save_Finger[5] = ucH_Char;
    002D9 92C0 014B STS	FP_Save_Finger+5,R12
(0157) 	FP_Save_Finger[6] = ucL_Char;
    002DB 92A0 014C STS	FP_Save_Finger+6,R10
(0158) 
(0159) 	for(i=0;i<7;i++) //计算校验和
    002DD 24AA      CLR	R10
    002DE C017      RJMP	0x02F6
(0160) 		temp = temp + FP_Save_Finger[i];
    002DF E486      LDI	R24,0x46
    002E0 E091      LDI	R25,1
    002E1 2DEA      MOV	R30,R10
    002E2 27FF      CLR	R31
    002E3 0FE8      ADD	R30,R24
    002E4 1FF9      ADC	R31,R25
    002E5 8020      LD	R2,Z
    002E6 2433      CLR	R3
    002E7 2444      CLR	R4
    002E8 2455      CLR	R5
    002E9 8068      LD	R6,Y
    002EA 8079      LDD	R7,Y+1
    002EB 808A      LDD	R8,Y+2
    002EC 809B      LDD	R9,Y+3
    002ED 0C62      ADD	R6,R2
    002EE 1C73      ADC	R7,R3
    002EF 1C84      ADC	R8,R4
    002F0 1C95      ADC	R9,R5
    002F1 8268      ST	Y,R6
    002F2 8279      STD	Y+1,R7
    002F3 828A      STD	Y+2,R8
    002F4 829B      STD	Y+3,R9
    002F5 94A3      INC	R10
    002F6 2D8A      MOV	R24,R10
    002F7 3087      CPI	R24,7
    002F8 F330      BCS	0x02DF
(0161) 
(0162) 	FP_Save_Finger[7]=(temp & 0x00FF00) >> 8; //存放校验数据
    002F9 E040      LDI	R20,0
    002FA EF5F      LDI	R21,0xFF
    002FB E060      LDI	R22,0
    002FC E070      LDI	R23,0
    002FD 8108      LD	R16,Y
    002FE 8119      LDD	R17,Y+1
    002FF 812A      LDD	R18,Y+2
    00300 813B      LDD	R19,Y+3
    00301 2304      AND	R16,R20
    00302 2315      AND	R17,R21
    00303 2326      AND	R18,R22
    00304 2337      AND	R19,R23
    00305 E088      LDI	R24,0x8
    00306 E090      LDI	R25,0
    00307 938A      ST	-Y,R24
    00308 940E 039C CALL	lsr32
    0030A 9300 014D STS	FP_Save_Finger+7,R16
(0163) 	FP_Save_Finger[8]= temp & 0x0000FF;
    0030C EF4F      LDI	R20,0xFF
    0030D E050      LDI	R21,0
    0030E E060      LDI	R22,0
    0030F E070      LDI	R23,0
    00310 8028      LD	R2,Y
    00311 8039      LDD	R3,Y+1
    00312 804A      LDD	R4,Y+2
    00313 805B      LDD	R5,Y+3
    00314 2224      AND	R2,R20
    00315 2235      AND	R3,R21
    00316 2246      AND	R4,R22
    00317 2257      AND	R5,R23
    00318 9220 014E STS	FP_Save_Finger+8,R2
(0164) 
(0165) 	for(i=0;i<6;i++)
    0031A 24AA      CLR	R10
    0031B C00A      RJMP	0x0326
(0166) 		UART1_Send_Byte(FP_Pack_Head[i]); //发送包头
    0031C E084      LDI	R24,4
    0031D E091      LDI	R25,1
    0031E 2DEA      MOV	R30,R10
    0031F 27FF      CLR	R31
    00320 0FE8      ADD	R30,R24
    00321 1FF9      ADC	R31,R25
    00322 8100      LD	R16,Z
    00323 940E 012A CALL	_USART1_Transmit
    00325 94A3      INC	R10
    00326 2D8A      MOV	R24,R10
    00327 3086      CPI	R24,6
    00328 F398      BCS	0x031C
(0167) 
(0168) 	for(i=0;i<9;i++)
    00329 24AA      CLR	R10
    0032A C00A      RJMP	0x0335
(0169) 		UART1_Send_Byte(FP_Save_Finger[i]); //发送命令将图像转换成特征码存放在CHAR_buffer1
    0032B E486      LDI	R24,0x46
    0032C E091      LDI	R25,1
    0032D 2DEA      MOV	R30,R10
    0032E 27FF      CLR	R31
    0032F 0FE8      ADD	R30,R24
    00330 1FF9      ADC	R31,R25
    00331 8100      LD	R16,Z
    00332 940E 012A CALL	_USART1_Transmit
    00334 94A3      INC	R10
    00335 2D8A      MOV	R24,R10
    00336 3089      CPI	R24,0x9
    00337 F398      BCS	0x032B
    00338 9624      ADIW	R28,4
    00339 940C 0393 JMP	pop_xgsetF03C
_FINGERPRINT_Recevice_Data:
  i                    --> R10
  ucLength             --> R12
    0033B 92AA      ST	-Y,R10
    0033C 92CA      ST	-Y,R12
    0033D 2EC0      MOV	R12,R16
(0170) }
(0171) 
(0172) //接收反馈数据缓冲
(0173) void FINGERPRINT_Recevice_Data(unsigned char ucLength)
(0174) {
(0175) 	unsigned char i;
(0176) 
(0177) 	for (i=0;i<ucLength;i++)
    0033E 24AA      CLR	R10
    0033F C00A      RJMP	0x034A
(0178) 		UART1_FINGERPRINT_RECEVICE_BUFFER[i] = UART1_Receive_Byte();
    00340 940E 0144 CALL	_USART1_Receive
    00342 E683      LDI	R24,0x63
    00343 E091      LDI	R25,1
    00344 2DEA      MOV	R30,R10
    00345 27FF      CLR	R31
    00346 0FE8      ADD	R30,R24
    00347 1FF9      ADC	R31,R25
    00348 8300      ST	Z,R16
    00349 94A3      INC	R10
    0034A 14AC      CP	R10,R12
    0034B F3A0      BCS	0x0340
    0034C 90C9      LD	R12,Y+
    0034D 90A9      LD	R10,Y+
    0034E 9508      RET
_FINGERPRINT_add_new_user:
  ucL_user             --> R12
  ucH_user             --> R10
    0034F 92AA      ST	-Y,R10
    00350 92CA      ST	-Y,R12
    00351 2EC2      MOV	R12,R18
    00352 2EA0      MOV	R10,R16
(0179) }
(0180) 
(0181) //指纹添加新用户
(0182) unsigned char FINGERPRINT_add_new_user(unsigned char ucH_user,unsigned char ucL_user)
(0183) {
(0184) 	do
(0185) 	{
(0186) 		FINGERPRINT_Cmd_Get_Img(); //获得指纹图像
    00353 DE27      RCALL	_FINGERPRINT_Cmd_Get_Img
(0187) 		FINGERPRINT_Recevice_Data(12); //接收12个长度的反馈码
    00354 E00C      LDI	R16,0xC
    00355 DFE5      RCALL	_FINGERPRINT_Recevice_Data
(0188) 	}
(0189) 	while(UART1_FINGERPRINT_RECEVICE_BUFFER[9]!=0x0); //检测是否成功的按了指纹
    00356 9020 016C LDS	R2,UART1_FINGERPRINT_RECEVICE_BUFFER+9
    00358 2022      TST	R2
    00359 F7C9      BNE	0x0353
(0190) 
(0191) 	FINGERPRINT_Cmd_Img_To_Buffer1(); //将图像转换成特征码存放在Buffer1中
    0035A DE3F      RCALL	_FINGERPRINT_Cmd_Img_To_Buffer1
(0192) 	FINGERPRINT_Recevice_Data(12); //接收12个长度的反馈码
    0035B E00C      LDI	R16,0xC
    0035C DFDE      RCALL	_FINGERPRINT_Recevice_Data
(0193) 
(0194) 	do
(0195) 	{
(0196) 		FINGERPRINT_Cmd_Get_Img(); //获得指纹图像
    0035D DE1D      RCALL	_FINGERPRINT_Cmd_Get_Img
(0197) 		FINGERPRINT_Recevice_Data(12); //接收12个长度的反馈码			 
    0035E E00C      LDI	R16,0xC
    0035F DFDB      RCALL	_FINGERPRINT_Recevice_Data
(0198) 	}
(0199) 	while(UART1_FINGERPRINT_RECEVICE_BUFFER[9]!=0x0);
    00360 9020 016C LDS	R2,UART1_FINGERPRINT_RECEVICE_BUFFER+9
    00362 2022      TST	R2
    00363 F7C9      BNE	0x035D
(0200) 
(0201) 	FINGERPRINT_Cmd_Img_To_Buffer2(); //将图像转换成特征码存放在Buffer2中
    00364 DE54      RCALL	_FINGERPRINT_Cmd_Img_To_Buffer2
(0202) 	FINGERPRINT_Recevice_Data(12); //接收12个长度的反馈码
    00365 E00C      LDI	R16,0xC
    00366 DFD4      RCALL	_FINGERPRINT_Recevice_Data
(0203) 
(0204) 	FINGERPRINT_Cmd_Reg_Model(); //转换成特征码
    00367 DE70      RCALL	_FINGERPRINT_Cmd_Reg_Model
(0205) 	FINGERPRINT_Recevice_Data(12);
    00368 E00C      LDI	R16,0xC
    00369 DFD1      RCALL	_FINGERPRINT_Recevice_Data
(0206) 
(0207) 	FINGERPRINT_Cmd_Save_Finger(ucH_user,ucL_user);
    0036A 2D2C      MOV	R18,R12
    0036B 2D0A      MOV	R16,R10
    0036C DF62      RCALL	_FINGERPRINT_Cmd_Save_Finger
(0208) 	FINGERPRINT_Recevice_Data(12);
    0036D E00C      LDI	R16,0xC
    0036E DFCC      RCALL	_FINGERPRINT_Recevice_Data
(0209) 
(0210) 	return 0;
    0036F 2700      CLR	R16
    00370 90C9      LD	R12,Y+
    00371 90A9      LD	R10,Y+
    00372 9508      RET
FILE: F:\工作\单片机\WorkSpace\AccessControlSystem\LCD_Operate.c
(0001) //LCD_Operate.c
(0002) 
(0003) #include <iom128v.h>
(0004) #include <macros.h>
(0005) #include "LCD_Operate.h"
(0006) #include "USART_Operate.h"
(0007) 
(0008) //LCD测忙
(0009) unsigned char LCD_Busy(void)
(0010) {
(0011) 	if(PINA & BIT(4))
_LCD_Busy:
    00373 9BCC      SBIS	0x19,4
    00374 C002      RJMP	0x0377
(0012) 		return 1;
    00375 E001      LDI	R16,1
    00376 C001      RJMP	0x0378
(0013) 	else
(0014) 		return 0;
    00377 2700      CLR	R16
    00378 9508      RET
_LCD_Clear_Screen:
  color                --> R10
    00379 92AA      ST	-Y,R10
    0037A 92BA      ST	-Y,R11
    0037B 0158      MOVW	R10,R16
(0015) }
(0016) 
(0017) //LCD清屏
(0018) void LCD_Clear_Screen(unsigned char *color)
(0019) {
(0020) 	USART0_Transmit_String("CLS(");
    0037C E50E      LDI	R16,0x5E
    0037D E011      LDI	R17,1
    0037E 940E 0107 CALL	_USART0_Transmit_String
(0021) 	USART0_Transmit_String(color);
    00380 0185      MOVW	R16,R10
    00381 940E 0107 CALL	_USART0_Transmit_String
(0022) 	USART0_Transmit_String(");\r\n");
FILE: <library>
    00383 E509      LDI	R16,0x59
    00384 E011      LDI	R17,1
    00385 940E 0107 CALL	_USART0_Transmit_String
    00387 90B9      LD	R11,Y+
    00388 90A9      LD	R10,Y+
    00389 9508      RET
push_xgsetF03C:
    0038A 937A      ST	-Y,R23
    0038B 936A      ST	-Y,R22
    0038C 935A      ST	-Y,R21
    0038D 934A      ST	-Y,R20
    0038E 92DA      ST	-Y,R13
    0038F 92CA      ST	-Y,R12
    00390 92BA      ST	-Y,R11
    00391 92AA      ST	-Y,R10
    00392 9508      RET
pop_xgsetF03C:
    00393 90A9      LD	R10,Y+
    00394 90B9      LD	R11,Y+
    00395 90C9      LD	R12,Y+
    00396 90D9      LD	R13,Y+
    00397 9149      LD	R20,Y+
    00398 9159      LD	R21,Y+
    00399 9169      LD	R22,Y+
    0039A 9179      LD	R23,Y+
    0039B 9508      RET
lsr32:
    0039C 920F      PUSH	R0
    0039D 9009      LD	R0,Y+
    0039E 2000      TST	R0
    0039F F031      BEQ	0x03A6
    003A0 9536      LSR	R19
    003A1 9527      ROR	R18
    003A2 9517      ROR	R17
    003A3 9507      ROR	R16
    003A4 940A      DEC	R0
    003A5 CFF8      RJMP	0x039E
    003A6 900F      POP	R0
    003A7 9508      RET
