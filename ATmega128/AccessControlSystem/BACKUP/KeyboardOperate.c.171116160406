//KeyboardOperate.c

#include <iom128v.h>
#include <macros.h>
#include "KeyboardOperate.h"
#include "GlobalDefine.h"

//判断按键是否按下
unsigned char Keyboard_Press(void)
{
	unsigned char temp;
	
	DDRB  = 0XFF; //设置PB口全为输出
	PORTB = 0XF0; //设置PB高四位为高电平, 以便进行判断
	DDRB  = 0X0F; //设置高四位为输入, 低四位为输出
	temp  = PINB; //读出IO口状态
	if(temp == 0XF0) //如果它等于0xF0就执返回0
	{
		DDRD = 0XFF; //将IO口值读回来
		return 0;
	}
	else //否则它就执返回1
	{
		DDRD = 0XFF;
		return 1;
	}
}

//判断按下的是哪个按键
unsigned char Keyboard_Scan(void)
{
	unsigned char temp, key = 0;
	
	//检测第一行按键
	DDRB  = 0xFF; //PB设为输出
	PORTB = 0x7F; //PB7以外全设为高电平
	DDRB  = 0x00; //PB设为输入
	temp  = PINB; //读出PB口的数值到temp
	temp &= 0x0F; //检查低四位
	if(temp != 0x0F) //若低四位不全是高电平, 说明有按键按下
	{
		delay(10); //消抖
		DDRB  = 0x00; //PB设为输入
		temp  = PINB; //读出PB口的数值到temp
		temp &= 0x0F; //再次检查低四位的电平
		if(temp != 0x0F) //若低四位还不全是高电平, 说明确实有按键按下
		{
			DDRB = 0x00; //PB设为输入
			temp = PINB; //读出PB口的数值到temp
			switch(temp) //判断是哪个按键按下
			{
				case 0x77: key = 0x00; DDRA = 0xFF; PORTB = 0x01; break;
				case 0x7B: key = 0x01; DDRA = 0xFF; PORTB = 0x02; break;
				case 0x7D: key = 0x02; DDRA = 0xFF; PORTB = 0x04; break;
				case 0x7E: key = 0x03; DDRA = 0xFF; PORTB = 0x08; break;
			}
		}
	}
	
	//检测第二行按键
	DDRB  = 0xFF; //PB设为输出
	PORTB = 0xBF; //PB7以外全设为高电平
	DDRB  = 0x00; //PB设为输入
	temp  = PINB; //读出PB口的数值到temp
	temp &= 0x0F; //检查低四位
	if(temp != 0x0F) //若低四位不全是高电平, 说明有按键按下
	{
		delay(10); //消抖
		DDRB  = 0x00; //PB设为输入
		temp  = PINB; //读出PB口的数值到temp
		temp &= 0x0F; //再次检查低四位的电平
		if(temp != 0x0F) //若低四位还不全是高电平, 说明确实有按键按下
		{
			DDRB = 0x00; //PB设为输入
			temp = PINB; //读出PB口的数值到temp
			switch(temp) //判断是哪个按键按下
			{
				case 0xB7: key = 0x04; break;
				case 0xBB: key = 0x05; break;
				case 0xBD: key = 0x06; break;
				case 0xBE: key = 0x07; break;
			}
		}
	}
	
	//检测第三行按键
	DDRB  = 0xFF; //PB设为输出
	PORTB = 0xDF; //PB7以外全设为高电平
	DDRB  = 0x00; //PB设为输入
	temp  = PINB; //读出PB口的数值到temp
	temp &= 0x0F; //检查低四位
	if(temp != 0x0F) //若低四位不全是高电平, 说明有按键按下
	{
		delay(10); //消抖
		DDRB  = 0x00; //PB设为输入
		temp  = PINB; //读出PB口的数值到temp
		temp &= 0x0F; //再次检查低四位的电平
		if(temp != 0x0F) //若低四位还不全是高电平, 说明确实有按键按下
		{
			DDRB = 0x00; //PB设为输入
			temp = PINB; //读出PB口的数值到temp
			switch(temp) //判断是哪个按键按下
			{
				case 0xD7: key = 0x08; break;
				case 0xDB: key = 0x09; break;
				case 0xDD: key = 0x0a; break;
				case 0xDE: key = 0x0b; break;
			}
		}
	}
	
	//检测第四行按键
	DDRB  = 0xFF; //PB设为输出
	PORTB = 0xEF; //PB7以外全设为高电平
	DDRB  = 0x00; //PB设为输入
	temp  = PINB; //读出PB口的数值到temp
	temp &= 0x0F; //检查低四位
	if(temp != 0x0F) //若低四位不全是高电平, 说明有按键按下
	{
		delay(10); //消抖
		DDRB  = 0x00; //PB设为输入
		temp  = PINB; //读出PB口的数值到temp
		temp &= 0x0F; //再次检查低四位的电平
		if(temp != 0x0F) //若低四位还不全是高电平, 说明确实有按键按下
		{
			DDRB = 0x00; //PB设为输入
			temp = PINB; //读出PB口的数值到temp
			switch(temp) //判断是哪个按键按下
			{
				case 0xE7: key = 0x0c; break;
				case 0xEB: key = 0x0d; break;
				case 0xED: key = 0x0e; break;
				case 0xEE: key = 0x0f; break;
			}
		}
	}
	return key;
}
